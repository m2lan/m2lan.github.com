<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识记录</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.golearns.org/"/>
  <updated>2017-05-30T07:14:23.000Z</updated>
  <id>http://blog.golearns.org/</id>
  
  <author>
    <name>M2</name>
    <email>763960267@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建DNS服务器实现域名解析</title>
    <link href="http://blog.golearns.org/2017/05/30/%E6%90%AD%E5%BB%BADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.golearns.org/2017/05/30/搭建DNS服务器实现域名解析/</id>
    <published>2017-05-30T05:53:40.000Z</published>
    <updated>2017-05-30T07:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux搭建DNS服务器实现域名解析"><a href="#Linux搭建DNS服务器实现域名解析" class="headerlink" title="Linux搭建DNS服务器实现域名解析"></a>Linux搭建DNS服务器实现域名解析</h1><blockquote>
<p>域名系统，可以提供域名与IP地址的解析服务。</p>
</blockquote>
<h3 id="BIND实现DNS服务器搭建"><a href="#BIND实现DNS服务器搭建" class="headerlink" title="BIND实现DNS服务器搭建"></a>BIND实现DNS服务器搭建</h3><ul>
<li><p>install</p>
<pre><code># 主程序
[root@m2lan150 ~]# rpm -ivh /mnt/Packages/bind-9.8.2-0.17.rc1.el6_4.6.x86_64.rpm
# 提高安全性
[root@m2lan150 ~]# rpm -ivh /mnt/Packages/bind-chroot-9.8.2-0.17.rc1.el6_4.6.x86_64.rpm
</code></pre></li>
<li><p>配置文件</p>
<pre><code># 包含bind的基本配置
[root@m2lan150 ~]# ls /etc/named.conf 
/etc/named.conf
</code></pre></li>
<li><p>启动服务</p>
<pre><code># 启动的时候卡在这个地方
[root@m2lan150 ~]# /etc/init.d/named start
Generating /etc/rndc.key:

# 启动bind时，需要生产rndc.key，使用手动生成
[root@m2lan150 ~]# rndc-confgen -r /dev/urandom -a
wrote key file &quot;/etc/rndc.key&quot;

# 再次启动
[root@m2lan150 ~]# /etc/init.d/named start
启动 named：                                               [确定]
</code></pre></li>
<li><p>启动后查看挂载，开启named服务后，会自动挂载，调用chroot功能切换根</p>
<pre><code>[root@m2lan150 ~]# mount | grep named
/etc/named on /var/named/chroot/etc/named type none (rw,bind)
/var/named on /var/named/chroot/var/named type none (rw,bind)
/etc/named.conf on /var/named/chroot/etc/named.conf type none (rw,bind)
/etc/named.rfc1912.zones on /var/named/chroot/etc/named.rfc1912.zones type none (rw,bind)
/etc/rndc.key on /var/named/chroot/etc/rndc.key type none (rw,bind)
/usr/lib64/bind on /var/named/chroot/usr/lib64/bind type none (rw,bind)
/etc/named.iscdlv.key on /var/named/chroot/etc/named.iscdlv.key type none (rw,bind)
/etc/named.root.key on /var/named/chroot/etc/named.root.key type none (rw,bind)
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="修改配置，解析m2lan-org"><a href="#修改配置，解析m2lan-org" class="headerlink" title="修改配置，解析m2lan.org"></a>修改配置，解析m2lan.org</h3><ul>
<li>配置文件<code>/var/named/chroot/etc/named.conf</code></li>
<li><p>named.conf分为三段</p>
<ul>
<li>options: 对全局生效</li>
<li>logging: 日志的配置</li>
<li>zone: 针对某个区域生效</li>
</ul>
</li>
<li><p>配置正向解析区域</p>
<ul>
<li>授权DNS服务器管理m2lan.org区域，并把该区域的区域文件命名为m2lan.org.zone</li>
<li><p>修改</p>
<pre><code>[root@m2lan150 named]# cat /var/named/chroot/etc/named.conf

options {
    # any监听任意端口、任意IP地址
    listen-on port 53 { any; };
    listen-on-v6 port 53 { any; };
    directory     &quot;/var/named&quot;;
    dump-file     &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
    # 允许所有人都可以查询
    allow-query     { any; };
    # 是否支持递归查询，默认是支持递归的，公网一般修改为no
    recursion yes;

    # DNS查询的时候是否支持安全的方式查询，如果允许的话，需要通过密钥的方式
    dnssec-enable yes;
    dnssec-validation yes;
    dnssec-lookaside auto;

    /* Path to ISC DLV key */
    bindkeys-file &quot;/etc/named.iscdlv.key&quot;;

    managed-keys-directory &quot;/var/named/dynamic&quot;;
};

logging {
        channel default_debug {
                file &quot;data/named.run&quot;;
                severity dynamic;
        };
};

zone &quot;.&quot; IN {
    type hint;
    file &quot;named.ca&quot;;
};

# 指定一个区域管理，管理m2lan.org
zone &quot;m2lan.org&quot; IN {
    # master表示主域名服务器, slave表示从域名服务器
    type master;
    # 指定区域文件
    file &quot;m2lan.org.zone&quot;;
};
include &quot;/etc/named.rfc1912.zones&quot;;
include &quot;/etc/named.root.key&quot;;
</code></pre></li>
<li><p>copy配置文件为m2lan.org.zone，并保持源文件权限-p</p>
<pre><code>[root@m2lan150 ~]# cd /var/named/chroot/var/named/
[root@m2lan150 named]# cp -p named.localhost m2lan.org.zone
</code></pre></li>
<li>配置m2lan.org.zone文件<ul>
<li>$TTL 1D: 设置有效地址解析记录的默认缓存时间，默认为1天1D</li>
<li>@表示当前的域m2lan.org.</li>
<li>设置SOA记录为: dns.m2lan.org.</li>
<li>域管理邮箱root.m2lan.org., 由于@有其他含义，所以用”.”代替@</li>
<li>0 ; serial: 更新序列号，用于标识数据库的变换，可以在10位以内，如果存在辅助DNS区域，建议每次更新玩数据库，手动加1.</li>
<li>1D ; refresh: 刷新时间，从域名服务器更新该地址数据库文件的间隔时间，默认为1天</li>
<li>1H ; retry: 重试延时，从域名服务器更新地址数据库失败以后，等待多长时间，默认为1小时</li>
<li>1W ; expire: 到期，失效时间，超过该时间仍无法更新地址数据库，则不再尝试，默认为一周</li>
<li>3H ) ; minimum: 设置无效地址解析记录(该数据库中不存在的地址)默认缓存时间。设置无效记录，最少缓存时间为3小时</li>
<li>资源记录参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOA</td>
<td>区域授权起始记录，区域文件第一条记录，而且一个区域文件只能有一条</td>
</tr>
<tr>
<td style="text-align:center">NS</td>
<td>域的授权名称服务器</td>
</tr>
<tr>
<td style="text-align:center">MX</td>
<td>域的邮件交换器，要跟着一个优先级值，越小越高</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td>IPV4主机地址</td>
</tr>
<tr>
<td style="text-align:center">AAAA</td>
<td>IPV6主机地址</td>
</tr>
<tr>
<td style="text-align:center">PTR</td>
<td>解析IP的指针</td>
</tr>
<tr>
<td style="text-align:center">CNAME</td>
<td>权威(正式)名称，定义别名记录</td>
</tr>
</tbody>
</table>
<pre><code>[root@m2lan150 named]# cat m2lan.org.zone
$TTL 1D
m2lan.org.    IN SOA    dns.m2lan.org. root.m2lan.org. (
                    0    ; serial
                    1D    ; refresh
                    1H    ; retry
                    1W    ; expire
                    3H )    ; minimum
m2lan.org.    NS    dns.m2lan.org.
dns.m2lan.org.    A    192.168.0.150
www.m2lan.org.   A       192.168.0.150
www1.m2lan.org.  CNAME       www.m2lan.org.
</code></pre><ul>
<li><p>重启named服务</p>
<pre><code>[root@m2lan150 ~]# service named restart
停止 named：.                                              [确定]
启动 named：                                               [确定]
</code></pre></li>
<li><p>修改本机的dns地址</p>
<pre><code>[root@m2lan150 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
TYPE=Ethernet
UUID=66cce682-8059-4f3e-b8e4-29a171e3bfaf
ONBOOT=yes
NM_CONTROLLED=yes
BOOTPROTO=none
IPADDR=192.168.0.150
PREFIX=24
GATEWAY=192.168.0.1
#DNS1=192.168.0.1
DNS1=192.168.0.150
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=no
NAME=&quot;System eth0&quot;
HWADDR=00:0c:29:25:5f:a1
NETMASK=255.255.255.0
USERCTL=no
</code></pre></li>
<li><p>重启network</p>
<pre><code>[root@m2lan150 ~]# service network restart
</code></pre></li>
<li><p>ping www.m2lan.org</p>
<pre><code>[root@m2lan150 ~]# ping -c 3 www.m2lan.org
PING www.m2lan.org (192.168.0.150) 56(84) bytes of data.
64 bytes from m2lan150.com (192.168.0.150): icmp_seq=1 ttl=64 time=0.016 ms
64 bytes from m2lan150.com (192.168.0.150): icmp_seq=2 ttl=64 time=0.034 ms
64 bytes from m2lan150.com (192.168.0.150): icmp_seq=3 ttl=64 time=0.038 ms

--- www.m2lan.org ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.016/0.029/0.038/0.010 ms
</code></pre></li>
</ul>
<h3 id="使DNS支持递归查询"><a href="#使DNS支持递归查询" class="headerlink" title="使DNS支持递归查询"></a>使DNS支持递归查询</h3><ul>
<li><p>配置<code>/var/named/chroot/etc/named.conf</code></p>
<pre><code># 是否支持递归查询，默认是支持递归的，公网一般修改为no
recursion yes;
# DNS查询的时候是否支持安全的方式查询，如果允许的话，需要通过密钥的方式
# 需要将一下三条注释，这样客户端才能通过这个DNS进行递归查询。
#dnssec-enable yes;
#dnssec-validation yes;
#dnssec-lookaside auto;
</code></pre></li>
<li><p>重启named服务</p>
<pre><code>[root@m2lan150 ~]# service named restart
</code></pre></li>
<li><p>将170服务器的DNS修改为192.168.0.150</p>
<pre><code>[root@m2lan170 ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0
DNS1=192.168.0.150
</code></pre></li>
<li><p>重启network</p>
<pre><code>[root@m2lan170 ~]# service network restart
</code></pre></li>
<li><p>ping www.m2lan.org</p>
<pre><code>[root@m2lan170 ~]# ping www.m2lan.org
</code></pre></li>
</ul>
<h3 id="搭建DNS转发服务器"><a href="#搭建DNS转发服务器" class="headerlink" title="搭建DNS转发服务器"></a>搭建DNS转发服务器</h3><ul>
<li><p>配置</p>
<pre><code>[root@m2lan150 ~]# cat /var/named/chroot/etc/named.conf | grep -v &apos;$#&apos; | grep -v &apos;^$&apos;
options {
    listen-on port 53 { any; };
    listen-on-v6 port 53 { any; };
    directory     &quot;/var/named&quot;;
    dump-file     &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
    allow-query     { any; };
    recursion yes;
    #dnssec-enable yes;
    #dnssec-validation yes;
    #dnssec-lookaside auto;

    # 增加两行
    # 仅支持转发操作。only: 仅转发，first: 先查找本地zone再转发
    forward only;
    # 将所有请求过来的地址转发到8.8.8.8
    forwarders {8.8.8.8;};
    /* Path to ISC DLV key */
    bindkeys-file &quot;/etc/named.iscdlv.key&quot;;
    managed-keys-directory &quot;/var/named/dynamic&quot;;
};
logging {
        channel default_debug {
                file &quot;data/named.run&quot;;
                severity dynamic;
        };
};
zone &quot;.&quot; IN {
    type hint;
    file &quot;named.ca&quot;;
};

include &quot;/etc/named.rfc1912.zones&quot;;
include &quot;/etc/named.root.key&quot;;
</code></pre></li>
<li><p>重启服务后在170服务器测试</p>
</li>
</ul>
<h3 id="搭建DNS主从服务器"><a href="#搭建DNS主从服务器" class="headerlink" title="搭建DNS主从服务器"></a>搭建DNS主从服务器</h3><blockquote>
<p><strong>150服务器为主DNS服务器，170服务器为从DNS服务器</strong></p>
</blockquote>
<ul>
<li><p>主服务器的配置</p>
<pre><code>[root@m2lan150 etc]# cat /var/named/chroot/etc/named.conf | grep -v &apos;^#&apos; | grep -v &apos;^$&apos;
options {
    listen-on port 53 { any; };
    listen-on-v6 port 53 { any; };
    directory     &quot;/var/named&quot;;
    dump-file     &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
    allow-query     { any; };
    recursion yes;
    #dnssec-enable yes;
    #dnssec-validation yes;
    #dnssec-lookaside auto;
    /* Path to ISC DLV key */
    bindkeys-file &quot;/etc/named.iscdlv.key&quot;;
    managed-keys-directory &quot;/var/named/dynamic&quot;;
};
logging {
        channel default_debug {
                file &quot;data/named.run&quot;;
                severity dynamic;
        };
};
zone &quot;.&quot; IN {
    type hint;
    file &quot;named.ca&quot;;
};
zone &quot;m2lan.org&quot; IN {
    type master;
    file &quot;m2lan.org.zone&quot;;
    # 指定允许哪个网段可以从DNS同步主DNS服务器zone文件，不写默认为所有。
    allow-transfer { 192.168.0.1/24; };
};
include &quot;/etc/named.rfc1912.zones&quot;;
include &quot;/etc/named.root.key&quot;;
</code></pre></li>
<li><p>启动主服务器</p>
</li>
<li><p>从服务器的配置</p>
<pre><code>[root@m2lan170 ~]# cat /var/named/chroot/etc/named.conf | grep -v &apos;^#&apos; | grep -v &apos;^$&apos;
options {
    listen-on port 53 { any; };
    listen-on-v6 port 53 { any; };
    directory     &quot;/var/named&quot;;
    dump-file     &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
    allow-query     { any; };
    recursion yes;
    #dnssec-enable yes;
    #dnssec-validation yes;
    #dnssec-lookaside auto;
    /* Path to ISC DLV key */
    bindkeys-file &quot;/etc/named.iscdlv.key&quot;;
    managed-keys-directory &quot;/var/named/dynamic&quot;;
};
logging {
        channel default_debug {
                file &quot;data/named.run&quot;;
                severity dynamic;
        };
};
zone &quot;.&quot; IN {
    type hint;
    file &quot;named.ca&quot;;
};
zone &quot;m2lan.org&quot; IN {
    # 设置为slave从DNS服务器
    type slave;
    # 本机是存在/var/named/chroot/var/named/slaves/目录的
    # 当启动从DNS服务器时会自动在/var/named/chroot/var/named/slaves/目录下创建名为m2lan.org.zone.file文件
    # 这个文件是从主DNS服务器获取的数据
    file &quot;slaves/m2lan.org.zone.file&quot;;
    # 指定主服务器的IP地址
    masters { 192.168.0.150; };
};
include &quot;/etc/named.rfc1912.zones&quot;;
include &quot;/etc/named.root.key&quot;;
</code></pre></li>
<li><p>启动从服务器</p>
<pre><code>[root@m2lan170 ~]# service named restart
停止 named：.                                              [确定]
启动 named：                                               [确定]
[root@m2lan170 ~]# ll /var/named/chroot/var/named/slaves/
总用量 4
-rw-r--r-- 1 named named 344 5月  29 16:28 m2lan.org.zone.file
</code></pre></li>
<li><p>修改主服务器的m2lan.org.zone配置文件</p>
<pre><code>[root@m2lan150 ~]# cat /var/named/chroot/var/named/m2lan.org.zone 
$TTL 1D
m2lan.org.    IN SOA    dns.m2lan.org. root.m2lan.org. (
                    # 每次修改后，将此处数值+1
                    1    ; serial
                    1D    ; refresh
                    1H    ; retry
                    1W    ; expire
                    3H )    ; minimum
m2lan.org.    NS    dns.m2lan.org.
dns.m2lan.org.    A    192.168.0.150

# 下面两行配置DNS负载均衡，1表示在客户端此记录保存为1s钟
www.m2lan.org.   1 A       192.168.0.150
www.m2lan.org.   1 A       192.168.0.170

www1.m2lan.org.  CNAME       www.m2lan.org.
</code></pre></li>
<li><p>重启主DNS服务器从服务器会自动同步配置，如果想手动同步就手动启动从服务器</p>
</li>
<li><p>测试</p>
<pre><code>[root@m2lan170 ~]# ping www.m2lan.org
PING www.m2lan.org (192.168.0.150) 56(84) bytes of data.

[root@m2lan170 ~]# ping www.m2lan.org
PING www.m2lan.org (192.168.0.170) 56(84) bytes of data.
</code></pre></li>
</ul>
<h3 id="DNS主从密钥认证"><a href="#DNS主从密钥认证" class="headerlink" title="DNS主从密钥认证"></a>DNS主从密钥认证</h3><ul>
<li><p>首先同步两台服务器的时间</p>
<pre><code>[root@m2lan150 ~]# cat /etc/ntp.conf | grep server
[root@m2lan150 ~]# ntpdate 0.rhel.pool.ntp.org
</code></pre></li>
<li><p>生成密钥，进行主从认证。在主DNS服务器上操作</p>
<ul>
<li>-a hmac-md5: 采用hmac-md5加密算法</li>
<li>-b 128: 生成的密钥长度为128位</li>
<li>-n 密钥类型，使用主机类型：HOST</li>
<li>-n <nametype>: ZONE | HOST | ENTITY | USER | OTHER
  (DNSKEY generation defaults to ZONE)</nametype></li>
<li><p>m2lan: 生成密钥的名称</p>
<pre><code>[root@m2lan150 chroot]# pwd
/var/named/chroot
[root@m2lan150 chroot]# dnssec-keygen -a hmac-md5 -b 128 -n HOST m2lan
Km2lan.+157+02765
[root@m2lan150 chroot]# ls
dev  etc  Km2lan.+157+02765.key  Km2lan.+157+02765.private  usr  var
</code></pre></li>
</ul>
</li>
<li><p>查看公钥，就是<code>buTZoOVOQgKtTpvLG/wwQw==</code></p>
<pre><code>[root@m2lan150 ~]# cat /var/named/chroot/Km2lan.+157+02765.key 
m2lan. IN KEY 512 3 157 buTZoOVOQgKtTpvLG/wwQw==
</code></pre></li>
<li><p>修改主服务器配置文件</p>
<pre><code>[root@m2lan150 ~]# cat /var/named/chroot/etc/named.conf | grep -v &apos;^#&apos; | grep -v &apos;^$&apos;
options {
    listen-on port 53 { any; };
    listen-on-v6 port 53 { any; };
    directory     &quot;/var/named&quot;;
    dump-file     &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
    allow-query     { any; };
    recursion yes;
    #dnssec-enable yes;
    #dnssec-validation yes;
    #dnssec-lookaside auto;
    /* Path to ISC DLV key */
    bindkeys-file &quot;/etc/named.iscdlv.key&quot;;
    managed-keys-directory &quot;/var/named/dynamic&quot;;
};
logging {
        channel default_debug {
                file &quot;data/named.run&quot;;
                severity dynamic;
        };
};
zone &quot;.&quot; IN {
    type hint;
    file &quot;named.ca&quot;;
};
# 定义一个key
key m2lankey {
    # 加密算法使用hmac-md5，和生成密钥采用的加密算法一致
    algorithm hmac-md5;
    # 密钥
    secret &quot;buTZoOVOQgKtTpvLG/wwQw==&quot;;
};
zone &quot;m2lan.org&quot; IN {
    type master;
    file &quot;m2lan.org.zone&quot;;
    # 使用密钥进行同步
    allow-transfer { key m2lankey; };
};
include &quot;/etc/named.rfc1912.zones&quot;;
include &quot;/etc/named.root.key&quot;;
</code></pre></li>
<li><p>修改从服务器配置文件</p>
<pre><code>[root@m2lan170 ~]# cat /var/named/chroot/etc/named.conf | grep -v &apos;^$&apos; | grep -v &apos;^#&apos;
options {
    listen-on port 53 { any; };
    listen-on-v6 port 53 { any; };
    directory     &quot;/var/named&quot;;
    dump-file     &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
    allow-query     { any; };
    recursion yes;
    #dnssec-enable yes;
    #dnssec-validation yes;
    #dnssec-lookaside auto;
    /* Path to ISC DLV key */
    bindkeys-file &quot;/etc/named.iscdlv.key&quot;;
    managed-keys-directory &quot;/var/named/dynamic&quot;;
};
logging {
        channel default_debug {
                file &quot;data/named.run&quot;;
                severity dynamic;
        };
};
zone &quot;.&quot; IN {
    type hint;
    file &quot;named.ca&quot;;
};
# 创建和主服务器一样的key
key m2lankey {
        algorithm hmac-md5;
        secret &quot;buTZoOVOQgKtTpvLG/wwQw==&quot;;
}
zone &quot;m2lan.org&quot; IN {
    type slave;
    file &quot;slaves/m2lan.org.zone.file&quot;;
    # 使用密钥和主服务器同步
    masters { 192.168.0.150 key m2lankey; };
};
include &quot;/etc/named.rfc1912.zones&quot;;
include &quot;/etc/named.root.key&quot;;
</code></pre></li>
<li><p>重启主从服务器</p>
<pre><code># 从服务器下先把同步文件删除
[root@m2lan170 ~]# rm -f /var/named/chroot/var/named/slaves/m2lan.org.zone.file
[root@m2lan170 ~]# ls /var/named/chroot/var/named/slaves/
[root@m2lan170 ~]# 

# 查看文件是否生成
[root@m2lan170 ~]# service named restart
停止 named：.                                              [确定]
启动 named：                                               [确定]
[root@m2lan170 ~]# ls /var/named/chroot/var/named/slaves/
m2lan.org.zone.file
</code></pre></li>
<li><p>使用nslookup测试</p>
<pre><code>[root@m2lan150 ~]# nslookup www.m2lan.org
Server:        192.168.0.150
Address:    192.168.0.150#53

Name:    www.m2lan.org
Address: 192.168.0.150
Name:    www.m2lan.org
Address: 192.168.0.170
</code></pre></li>
<li><p>使用dig测试</p>
<pre><code># 指定dns解析
[root@m2lan150 ~]# dig @8.8.8.8 www.m2lan.org
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux搭建DNS服务器实现域名解析&quot;&gt;&lt;a href=&quot;#Linux搭建DNS服务器实现域名解析&quot; class=&quot;headerlink&quot; title=&quot;Linux搭建DNS服务器实现域名解析&quot;&gt;&lt;/a&gt;Linux搭建DNS服务器实现域名解析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;域名系统，可以提供域名与IP地址的解析服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;BIND实现DNS服务器搭建&quot;&gt;&lt;a href=&quot;#BIND实现DNS服务器搭建&quot; class=&quot;headerlink&quot; title=&quot;BIND实现DNS服务器搭建&quot;&gt;&lt;/a&gt;BIND实现DNS服务器搭建&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;install&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 主程序
[root@m2lan150 ~]# rpm -ivh /mnt/Packages/bind-9.8.2-0.17.rc1.el6_4.6.x86_64.rpm
# 提高安全性
[root@m2lan150 ~]# rpm -ivh /mnt/Packages/bind-chroot-9.8.2-0.17.rc1.el6_4.6.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 包含bind的基本配置
[root@m2lan150 ~]# ls /etc/named.conf 
/etc/named.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 启动的时候卡在这个地方
[root@m2lan150 ~]# /etc/init.d/named start
Generating /etc/rndc.key:

# 启动bind时，需要生产rndc.key，使用手动生成
[root@m2lan150 ~]# rndc-confgen -r /dev/urandom -a
wrote key file &amp;quot;/etc/rndc.key&amp;quot;

# 再次启动
[root@m2lan150 ~]# /etc/init.d/named start
启动 named：                                               [确定]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动后查看挂载，开启named服务后，会自动挂载，调用chroot功能切换根&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# mount | grep named
/etc/named on /var/named/chroot/etc/named type none (rw,bind)
/var/named on /var/named/chroot/var/named type none (rw,bind)
/etc/named.conf on /var/named/chroot/etc/named.conf type none (rw,bind)
/etc/named.rfc1912.zones on /var/named/chroot/etc/named.rfc1912.zones type none (rw,bind)
/etc/rndc.key on /var/named/chroot/etc/rndc.key type none (rw,bind)
/usr/lib64/bind on /var/named/chroot/usr/lib64/bind type none (rw,bind)
/etc/named.iscdlv.key on /var/named/chroot/etc/named.iscdlv.key type none (rw,bind)
/etc/named.root.key on /var/named/chroot/etc/named.root.key type none (rw,bind)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
      <category term="DNS" scheme="http://blog.golearns.org/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>搭建FTP服务器实现文件共享</title>
    <link href="http://blog.golearns.org/2017/05/29/%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    <id>http://blog.golearns.org/2017/05/29/搭建FTP服务器实现文件共享/</id>
    <published>2017-05-29T14:33:24.000Z</published>
    <updated>2017-05-29T14:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下搭建FTP服务器实现文件共享"><a href="#Linux下搭建FTP服务器实现文件共享" class="headerlink" title="Linux下搭建FTP服务器实现文件共享"></a>Linux下搭建FTP服务器实现文件共享</h1><blockquote>
<p>文件传输协议</p>
</blockquote>
<h3 id="安装vsftp"><a href="#安装vsftp" class="headerlink" title="安装vsftp"></a>安装vsftp</h3><ul>
<li><p>install</p>
<pre><code>[root@m2lan150 ~]# rpm -ivh /mnt/Packages/vsftpd-2.2.2-11.el6_4.1.x86_64.rpm
</code></pre></li>
<li><p>配置文件</p>
<pre><code>[root@m2lan150 ~]# ll /etc/vsftpd/vsftpd.conf
</code></pre></li>
<li><p>启动服务</p>
<pre><code>[root@m2lan150 ~]# /etc/init.d/vsftpd start
为 vsftpd 启动 vsftpd：                                    [确定]
</code></pre></li>
<li><p>设置开机启动</p>
<pre><code>[root@m2lan150 ~]# chkconfig vsftpd on
</code></pre></li>
<li><p>查看端口</p>
<pre><code>[root@m2lan150 ~]# netstat -antup | grep vsftpd
tcp        0      0 0.0.0.0:21                  0.0.0.0:*                   LISTEN      15539/vsftpd
</code></pre></li>
<li><p>默认的共享路径</p>
<pre><code>[root@m2lan150 ~]# ls /var/ftp/
pub
</code></pre></li>
</ul>
<a id="more"></a>
<ul>
<li><p>windows下访问</p>
<pre><code>ftp://192.168.0.150
</code></pre></li>
<li><p>170服务器安装lftp并访问</p>
<pre><code>[root@m2lan170 ~]# rpm -ivh /mnt/Packages/lftp-4.0.9-1.el6.x86_64.rpm 
warning: /mnt/Packages/lftp-4.0.9-1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY
Preparing...                ########################################### [100%]
   1:lftp                   ########################################### [100%]

[root@m2lan170 ~]# lftp 192.168.0.150
lftp 192.168.0.150:~&gt; ls
drwxr-xr-x    2 0        0            4096 Feb 12  2013 pub
lftp 192.168.0.150:/&gt; exit
</code></pre></li>
</ul>
<h3 id="部分配置文件说明"><a href="#部分配置文件说明" class="headerlink" title="部分配置文件说明"></a>部分配置文件说明</h3><ul>
<li><p>/etc/vsftp/vsftp.conf</p>
<pre><code># 是否允许匿名用户访问
anonymous_enable=YES
# 是否允许本机用户登陆
local_enable=YES
# 是否允许上传
write_enable=YES
# 是否允许匿名用户上传
anon_upload_enable=YES
# 是否允许匿名用户创建新的目录
anon_mkdir_write_enable=YES
</code></pre></li>
</ul>
<h3 id="允许匿名用户上传和下载"><a href="#允许匿名用户上传和下载" class="headerlink" title="允许匿名用户上传和下载"></a>允许匿名用户上传和下载</h3><ul>
<li><p>备份配置文件</p>
<pre><code>[root@m2lan150 ~]# cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak
</code></pre></li>
<li><p>配置</p>
<pre><code>anonymous_enable=YES
local_enable=YES
write_enable=YES
local_umask=022
anon_upload_enable=YES
anon_mkdir_write_enable=YES
</code></pre></li>
<li><p>创建datas目录</p>
<pre><code>[root@m2lan150 ~]# mkdir /var/ftp/datas
</code></pre></li>
<li><p>修改datas目录所有者</p>
<pre><code>[root@m2lan150 ~]# chown ftp /var/ftp/datas
</code></pre></li>
</ul>
<h3 id="创建两个ftp账户ftpuser1和ftpuser2进行登陆验证并禁止匿名登陆"><a href="#创建两个ftp账户ftpuser1和ftpuser2进行登陆验证并禁止匿名登陆" class="headerlink" title="创建两个ftp账户ftpuser1和ftpuser2进行登陆验证并禁止匿名登陆"></a>创建两个ftp账户ftpuser1和ftpuser2进行登陆验证并禁止匿名登陆</h3><pre><code>[root@m2lan150 ~]# useradd -s /sbin/nologin ftpuser1
[root@m2lan150 ~]# useradd -s /sbin/nologin ftpuser2

[root@m2lan150 ~]# echo &apos;123456&apos; | passwd --stdin ftpuser1
[root@m2lan150 ~]# echo &apos;123456&apos; | passwd --stdin ftpuser2
</code></pre><ul>
<li><p>配置</p>
<pre><code># 禁止匿名登陆
anonymous_enable=NO

# 设置本地用户的根目录为/vsftp/html
local_root=/vsftp/html
# 开启chroot功能
chroot_list_enable=YES
# 设置锁定用户的列表文件，存放要锁定的用户名
chroot_list_file=/etc/vsftpd/chroot_list
</code></pre></li>
<li><p>创建chroot_list</p>
<pre><code>[root@m2lan150 ~]# touch /etc/vsftpd/chroot_list

[root@m2lan150 ~]# cat !$
cat /etc/vsftpd/chroot_list
ftpuser1
ftpuser2
</code></pre></li>
<li><p>创建/vsftp/html并修改权限</p>
<pre><code>[root@m2lan150 ~]# mkdir -p /vsftp/html
[root@m2lan150 ~]# ll -d /vsftp/html
drwxr-xr-x 2 root root 4096 5月  29 17:47 /vsftp/html
[root@m2lan150 ~]# chmod -R 0757 /vsftp/html/
</code></pre></li>
<li><p>重启服务</p>
<pre><code>[root@m2lan150 ~]# service vsftpd restart
关闭 vsftpd：                                              [确定]
为 vsftpd 启动 vsftpd：                                    [确定]
</code></pre></li>
</ul>
<h3 id="使用虚拟用户"><a href="#使用虚拟用户" class="headerlink" title="使用虚拟用户"></a>使用虚拟用户</h3><ul>
<li>创建ftp和vip用户，根据不同等级限速<ul>
<li>公共账户ftp用户只允许下载</li>
<li>客户账户vip用户允许上传和下载</li>
</ul>
</li>
<li><p>创建虚拟用户文件</p>
<pre><code>[root@m2lan150 ~]# cat !$
cat /etc/vsftpd/vvuser.txt
ftp
123456
vip
123456
</code></pre></li>
<li><p>生成数据库文件</p>
<ul>
<li>-T 转换</li>
<li>-t hash加密</li>
<li><p>-f 指定转换文件 </p>
<p>  [root@m2lan150 ~]# db_load -T -t hash -f /etc/vsftpd/vvuser.txt /etc/vsftpd/vvuser.db</p>
</li>
</ul>
</li>
<li><p>修改数据库文件访问权限</p>
<pre><code>[root@m2lan150 vsftpd]# chmod 600 vvuser.db
</code></pre></li>
<li><p>配置PAM文件</p>
<ul>
<li><p>为了使服务器能够使用数据库文件，对客户端进行身份验证，需要调用系统的PAM模块</p>
<pre><code>[root@m2lan150 ~]# cat /etc/pam.d/vsftpd 
auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/vvuser
account required /lib64/security/pam_userdb.so db=/etc/vsftpd/vvuse
</code></pre></li>
</ul>
</li>
<li><p>创建虚拟账号对应的系统用户和ftp共享的目录</p>
<ul>
<li>对于公共账号和客户账号，因为需要配置不同的权限，所以可以将两个账号的目录进行隔离，控制用户的文件访问。</li>
<li>公共账号<strong>ftp</strong>对应系统账户<strong>ftpuser</strong>，并将其主目录设置为/vsftp/ftp</li>
<li><p>客户账号<strong>vip</strong>对应系统账户<strong>vipuser</strong>，并将其主目录设置为/vsftp/vip</p>
<pre><code>[root@m2lan150 ~]# useradd -d /vsftp/ftp ftpuser
[root@m2lan150 ~]# useradd -d /vsftp/vip vipuser

# 设置权限
# 设置ftp目录只有读权限
[root@m2lan150 ~]# chmod -R 500 /vsftp/ftp/
[root@m2lan150 ~]# ll -d !$
ll -d /vsftp/ftp/
dr-x------ 4 ftpuser ftpuser 4096 5月  29 18:33 /vsftp/ftp/

# 设置vip目录有读写权限
[root@m2lan150 ~]# chmod -R 700 /vsftp/vip/
[root@m2lan150 ~]# ll -d !$
ll -d /vsftp/vip/
drwx------ 4 vipuser vipuser 4096 5月  29 18:33 /vsftp/vip/
</code></pre></li>
</ul>
</li>
<li><p>建立配置文件</p>
<ul>
<li><p>修改vsftpd.conf配置文件</p>
<pre><code>[root@m2lan150 ~]# cat /etc/vsftpd/vsftpd.conf | grep -v &apos;^$&apos; | grep -v &apos;^#&apos;
anonymous_enable=NO
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=YES
pam_service_name=vsftpd
# 设置用户的配置文件目录
user_config_dir=/etc/vsftpd/userconfig
# 设置FTP服务器最大接入客户端为300个
max_clients=300
# 设置每个IP地址最大连接数为10个
max_per_ip=10
userlist_enable=YES
tcp_wrappers=YES
</code></pre></li>
<li><p>在<code>user_config_dir</code>目录下为每个虚拟账号建立独立的配置文件</p>
<pre><code># 创建目录
[root@m2lan150 ~]# mkdir /etc/vsftpd/userconfig

# 为两个账号创建配置文件
[root@m2lan150 ~]# touch /etc/vsftpd/userconfig/ftp
[root@m2lan150 ~]# touch /etc/vsftpd/userconfig/vip
</code></pre></li>
<li><p>公共账户ftp配置文件</p>
<pre><code>[root@m2lan150 ~]# cat /etc/vsftpd/userconfig/ftp
# 开启虚拟账号登陆
guest_enable=yes
# 对应的系统账号
guest_username=ftpuser
# 不允许匿名账户浏览整个文件系统
anon_world_readable_only=no
# 最大传输速度，50kb/s
anon_max_rate=50000
</code></pre></li>
<li><p>客户账户vip配置文件</p>
<pre><code>[root@m2lan150 ~]# cat /etc/vsftpd/userconfig/vip
# 开启虚拟账号登陆
guest_enable=yes
# 对应的系统账号
guest_username=vipuser
# 不允许匿名账户浏览整个文件系统
anon_world_readable_only=no
# 允许在文件系统的写入权限
write_enable=yes
# 允许创建文件夹
anon_mkdir_write_enable=yes
# 开启匿名账号的上传功能
anon_upload_enable=yes
# 开启删除修改
anon_other_write_enable=yes
# 最大传输速度，100kb/s
anon_max_rate=100000
</code></pre></li>
<li><p>重启服务</p>
<pre><code>[root@m2lan150 ~]# service vsftpd restart
关闭 vsftpd：                                              [确定]
为 vsftpd 启动 vsftpd：                                    [确定]
</code></pre></li>
<li><p>windows测试，使用ftp工具</p>
</li>
<li><p>linux测试,使用lftp</p>
<ul>
<li>get下载文件</li>
<li>mirror下载文件夹</li>
<li>mirror -R 上传文件夹</li>
<li>rm 删除文件或文件夹</li>
<li><p>使用ftp用户登陆</p>
<pre><code>[root@m2lan170 ~]# lftp 192.168.0.150 -u ftp,123456
lftp ftp@192.168.0.150:~&gt; ls
-rw-r--r--    1 0        0            1979 May 29 11:03 passwd
drwxr-xr-x    2 0        0            4096 May 29 11:03 sh
lftp ftp@192.168.0.150:/&gt; get passwd 
1979 bytes transferred
lftp ftp@192.168.0.150:/&gt; !ls
anaconda-ks.cfg  install.log  install.log.syslog  passwd  xxx.txt  公共的  模板  视频  图片  文档  下载  音乐  桌面
lftp ftp@192.168.0.150:/&gt; mirror sh/
Total: 1 directory, 21 files, 0 symlinks              
New: 21 files, 0 symlinks
3872 bytes transferred
lftp ftp@192.168.0.150:/&gt; !ls
anaconda-ks.cfg  install.log  install.log.syslog  passwd  sh  xxx.txt  公共的  模板  视频  图片  文档  下载  音乐  桌面
</code></pre></li>
<li><p>使用vip用户登陆</p>
<pre><code>[root@m2lan170 ~]# lftp 192.168.0.150 -u vip,123456
lftp vip@192.168.0.150:~&gt; !ls
anaconda-ks.cfg  install.log  install.log.syslog  passwd  sh  xxx.txt  公共的  模板  视频  图片  文档  下载  音乐  桌面
lftp vip@192.168.0.150:~&gt; put install.log
54118 bytes transferred                          
lftp vip@192.168.0.150:/&gt; ls
-rw-------    1 506      506         54118 May 29 14:22 install.log
lftp vip@192.168.0.150:/&gt; mirror -R sh/
Total: 1 directory, 21 files, 0 symlinks 
New: 21 files, 0 symlinks
3872 bytes transferred
lftp vip@192.168.0.150:/&gt; ls
-rw-------    1 506      506         54118 May 29 14:22 install.log
drwx------    2 506      506          4096 May 29 14:25 sh
lftp vip@192.168.0.150:/&gt; rm -f install.log 
rm 成功, 删除 `install.log&apos;
lftp vip@192.168.0.150:/&gt; ls
drwx------    2 506      506          4096 May 29 14:25 sh
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下搭建FTP服务器实现文件共享&quot;&gt;&lt;a href=&quot;#Linux下搭建FTP服务器实现文件共享&quot; class=&quot;headerlink&quot; title=&quot;Linux下搭建FTP服务器实现文件共享&quot;&gt;&lt;/a&gt;Linux下搭建FTP服务器实现文件共享&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;文件传输协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装vsftp&quot;&gt;&lt;a href=&quot;#安装vsftp&quot; class=&quot;headerlink&quot; title=&quot;安装vsftp&quot;&gt;&lt;/a&gt;安装vsftp&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;install&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# rpm -ivh /mnt/Packages/vsftpd-2.2.2-11.el6_4.1.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# ll /etc/vsftpd/vsftpd.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# /etc/init.d/vsftpd start
为 vsftpd 启动 vsftpd：                                    [确定]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置开机启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# chkconfig vsftpd on
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# netstat -antup | grep vsftpd
tcp        0      0 0.0.0.0:21                  0.0.0.0:*                   LISTEN      15539/vsftpd
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认的共享路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# ls /var/ftp/
pub
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
      <category term="FTP" scheme="http://blog.golearns.org/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>samba服务配置实现文件共享</title>
    <link href="http://blog.golearns.org/2017/05/29/samba%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    <id>http://blog.golearns.org/2017/05/29/samba服务配置实现文件共享/</id>
    <published>2017-05-29T07:40:49.000Z</published>
    <updated>2017-05-29T07:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下samba服务器配置实现文件共享"><a href="#Linux下samba服务器配置实现文件共享" class="headerlink" title="Linux下samba服务器配置实现文件共享"></a>Linux下samba服务器配置实现文件共享</h1><blockquote>
<p>samba可以在Linux系统和Windows系统之间进行通信，实现不同操作系统之间的资源共享。</p>
<p>samba服务器端口号为139和445。</p>
</blockquote>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><ul>
<li><p>在150服务器上安装samba服务端</p>
<pre><code>[root@m2lan150 ~]# rpm -ivh /mnt/Packages/samba-3.6.9-164.el6.x86_64.rpm
</code></pre></li>
<li><p>在170服务器上安装samba客户端</p>
<pre><code>[root@m2lan170 ~]# rpm -ivh /mnt/Packages/samba-client-3.6.9-164.el6.x86_64.rpm
</code></pre></li>
</ul>
<h3 id="服务启动和关闭"><a href="#服务启动和关闭" class="headerlink" title="服务启动和关闭"></a>服务启动和关闭</h3><ul>
<li><p>samba服务器启动</p>
<pre><code>[root@m2lan150 ~]# /etc/init.d/smb start
||
[root@m2lan150 ~]# /etc/init.d/smb restart
</code></pre></li>
<li><p>服务配置重新加载，在不重启服务的情况下，加载配置文件</p>
<pre><code>[root@m2lan150 ~]# /etc/init.d/smb reload
</code></pre></li>
<li><p>设置开机自动启动</p>
<pre><code>[root@m2lan150 ~]# chkconfig smb on
</code></pre></li>
</ul>
<h3 id="查看端口号"><a href="#查看端口号" class="headerlink" title="查看端口号"></a>查看端口号</h3><pre><code>[root@m2lan150 ~]# netstat -antup | grep smb
tcp        0      0 0.0.0.0:139                 0.0.0.0:*                   LISTEN      11677/smbd          
tcp        0      0 0.0.0.0:445                 0.0.0.0:*                   LISTEN      11677/smbd          
tcp        0      0 :::139                      :::*                        LISTEN      11677/smbd          
tcp        0      0 :::445                      :::*                        LISTEN      11677/smbd
</code></pre><a id="more"></a>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li><p>配置文件配置步骤</p>
<ul>
<li>编辑主配置文件smb.conf,指定需要共享的目录，并为共享目录设置共享权限。</li>
<li>在smb.conf文件中指定日志文件名称和路径。</li>
<li>设置共享目录的本地系统权限和samba共享权限。</li>
<li>重启smb服务。</li>
</ul>
</li>
<li><p>[global]全局配置</p>
</li>
<li><p>samba服务器安全模式</p>
<pre><code># user、share和server，其中share和server已被废弃
# share安全模式不需要输入用户名和密码就可以访问samba服务器资源，匿名访问
# user安全模式输入正确的用户名和密码后才能访问
Scurity can be set to user, share(deprecated) or server(deprecated)
</code></pre></li>
<li><p>配置文件说明</p>
<pre><code># 全局配置
[global]
# 定义允许访问的客户端
hosts allow = 127. 192.168.12. 192.168.13.
# 定义禁止访问的客户端
# 当定义192.168.0.的时候表示禁止所有来自192.168.0.0/24网段的IP访问
# 禁止单个IP访问192.168.0.111
hosts deny = 192.168.0.
# 当hosts allow和hosts deny同时存在的时候，hosts allow优先级高

# 设置共享名
[public]
# 描述
comment = Public Stuff
# 共享的绝对路径
path = /home/samba
# 为yes可以匿名查看
public = yes
# 设置访问的用户名
valid users = %S
# 设置访问的用户组
valid users = MYDOMAIN\%S
# 为yes是只读，no是读写
readonly=no
# 设置目录可写，yes是读写，no是只读
writable = yes
printable = no
# 设置可写的用户名或用户组@组名
write list = +staff
# 是否允许查看共享内容，如果为no，可以通过绝对路径查看
browseable = no
</code></pre></li>
<li><p>备份配置文件</p>
<pre><code>[root@m2lan150 ~]# cp /etc/samba/smb.conf /etc/samba/smb.conf.bak
</code></pre></li>
<li><p>配置只允许指定的用户组的用户访问共享目录shares</p>
<pre><code># 创建一个用户组shares
[root@m2lan150 ~]# groupadd shares

# 创建两个测试用户share1和share2
[root@m2lan150 ~]# useradd -g shares share1    
[root@m2lan150 ~]# useradd -g shares share2

# 查看用户信息
[root@m2lan150 ~]# id share1
uid=501(share1) gid=501(shares) 组=501(shares)
[root@m2lan150 ~]# id share2
uid=502(share2) gid=501(shares) 组=501(shares)

# 创建samba用户share1和share2
# 第一次密码库文件不存在，会自动创建/etc/samba/smbpasswd
[root@m2lan150 ~]# smbpasswd -a share1
New SMB password:
Retype new SMB password:
startsmbfilepwent_internal: file /etc/samba/smbpasswd did not exist. File successfully created.
Added user share1.

[root@m2lan150 ~]# smbpasswd -a share2
New SMB password:
Retype new SMB password:
Added user share2.

# 配置
# 全局配置文件
[global]
security = user
passdb backend = smbpasswd
smb passwd file = /etc/samba/smbpasswd

[root@m2lan150 ~]# tail -n 5 /etc/samba/smb.conf
;    write list = +staff
[shares]
comment = shares dir 
path = /shares
valid users = @shares

# 创建/shares目录并cp一些文件
[root@m2lan150 ~]# mkdir /shares
[root@m2lan150 ~]# cp /etc/passwd !$
cp /etc/passwd /shares
[root@m2lan150 ~]# ls /shares/
passwd

# 重启samba服务
[root@m2lan150 ~]# service smb restart
关闭 SMB 服务：                                            [确定]
启动 SMB 服务：                                            [确定]

# 在windows下测试输入\\192.168.0.150输入用户名密码可以访问
</code></pre></li>
</ul>
<h3 id="设置可写权限"><a href="#设置可写权限" class="headerlink" title="设置可写权限"></a>设置可写权限</h3><ul>
<li><p>设置可写权限</p>
<pre><code>[shares]
comment = shares dir
path = /shares
valid users = @shares
writable = yes
</code></pre></li>
<li><p>设置共享目录权限</p>
<pre><code>[root@m2lan150 ~]# chmod 777 /shares
[root@m2lan150 ~]# ll -d !$
ll -d /shares
drwxrwxrwx 2 root root 4096 5月  29 12:02 /shares
</code></pre></li>
<li><p>重启服务</p>
<pre><code>[root@m2lan150 ~]# service smb restart
关闭 SMB 服务：                                            [确定]
启动 SMB 服务：                                            [确定]
</code></pre></li>
<li><p>现在windows再次访问就可以做写入操作</p>
</li>
</ul>
<h3 id="如果允许zhangsan用户和shares组成员可以读写-shares共享目录配置"><a href="#如果允许zhangsan用户和shares组成员可以读写-shares共享目录配置" class="headerlink" title="如果允许zhangsan用户和shares组成员可以读写/shares共享目录配置"></a>如果允许zhangsan用户和shares组成员可以读写/shares共享目录配置</h3><pre><code>[shares]
comment = shares dir
path = /shares
write list = zhangsan,@shares
</code></pre><h3 id="配置只能share1用户能看见-datas共享目录"><a href="#配置只能share1用户能看见-datas共享目录" class="headerlink" title="配置只能share1用户能看见/datas共享目录"></a>配置只能share1用户能看见/datas共享目录</h3><pre><code># 配置/datas共享目录，对所有用户隐藏
[root@m2lan150 ~]# tail -n 5 /etc/samba/smb.conf
[datas]
comment = datas dir
path = /datas
browseable = no

# 在[global]中添加
config file = /etc/samba/smb.conf.%U
# 如下：[global]中配置
workgroup = MYGROUP
server string = Samba Server Version %v
config file = /etc/samba/smb.conf.%U

# 创建/etc/samba/smb.conf.share1文件
[root@m2lan150 ~]# cp /etc/samba/smb.conf /etc/samba/smb.conf.share1
# 修改配置,将smb.conf.share1文件的browseable设置为yes
[datas]
comment = datas dir
path = /datas
browseable = yes

[root@m2lan150 ~]# mkdir /datas
[root@m2lan150 ~]# cp /etc/passwd !$
cp /etc/passwd /datas
[root@m2lan150 ~]# service smb restart
关闭 SMB 服务：                                            [确定]
启动 SMB 服务：                                            [确定]

# 使用share1和share2登陆发现share1可以看见，share2看不见
</code></pre><h3 id="win10下映射网络驱动器"><a href="#win10下映射网络驱动器" class="headerlink" title="win10下映射网络驱动器"></a>win10下映射网络驱动器</h3><ul>
<li><p>在网络上右键映射网络驱动器</p>
<pre><code>\\192.168.0.150\datas
</code></pre></li>
</ul>
<h3 id="在170服务器上查看"><a href="#在170服务器上查看" class="headerlink" title="在170服务器上查看"></a>在170服务器上查看</h3><ul>
<li><p>使用匿名方式查看</p>
<pre><code>[root@m2lan170 ~]# smbclient -L 192.168.0.150
Enter root&apos;s password: 
Anonymous login successful
Domain=[MYGROUP] OS=[Unix] Server=[Samba 3.6.9-164.el6]

    Sharename       Type      Comment
    ---------       ----      -------
    shares          Disk      shares dir
    IPC$            IPC       IPC Service (Samba Server Version 3.6.9-164.el6)
Anonymous login successful
Domain=[MYGROUP] OS=[Unix] Server=[Samba 3.6.9-164.el6]

    Server               Comment
    ---------            -------

    Workgroup            Master
    ---------            -------
</code></pre></li>
<li><p>使用share1用户查看</p>
<pre><code>[root@m2lan170 ~]# smbclient -L 192.168.0.150 -U share1%123456
Domain=[MYGROUP] OS=[Unix] Server=[Samba 3.6.9-164.el6]

    Sharename       Type      Comment
    ---------       ----      -------
    IPC$            IPC       IPC Service (Samba Server Version 3.6.9-164.el6)
    datas           Disk      datas dir
    shares          Disk      shares dir
Domain=[MYGROUP] OS=[Unix] Server=[Samba 3.6.9-164.el6]

    Server               Comment
    ---------            -------

    Workgroup            Master
    ---------            -------
</code></pre></li>
<li><p>使用share2用户查看</p>
<pre><code>[root@m2lan170 ~]# smbclient -L 192.168.0.150 -U share2%123456
Domain=[MYGROUP] OS=[Unix] Server=[Samba 3.6.9-164.el6]

    Sharename       Type      Comment
    ---------       ----      -------
    shares          Disk      shares dir
    IPC$            IPC       IPC Service (Samba Server Version 3.6.9-164.el6)
Domain=[MYGROUP] OS=[Unix] Server=[Samba 3.6.9-164.el6]

    Server               Comment
    ---------            -------

    Workgroup            Master
    ---------            -------
</code></pre></li>
<li><p>使用smbclient链接</p>
<ul>
<li>put上传</li>
<li><p>get下载 </p>
<pre><code>[root@m2lan170 ~]# smbclient //192.168.0.150/shares -U share2%123456
Domain=[MYGROUP] OS=[Unix] Server=[Samba 3.6.9-164.el6]
smb: \&gt; ls
  .                                   D        0  Mon May 29 12:16:46 2017
  ..                                 DR        0  Mon May 29 14:48:01 2017
  xxx.txt                             A        0  Mon May 29 12:16:45 2017
  passwd                                    1801  Mon May 29 12:02:13 2017

        39371 blocks of size 262144. 19964 blocks available
smb: \&gt; !ls
anaconda-ks.cfg  install.log  install.log.syslog  公共的  模板    视频  图片  文档  下载    音乐  桌面
smb: \&gt; put install.log
putting file install.log as \install.log (8808.1 kb/s) (average 8808.3 kb/s)
smb: \&gt; ls
  .                                   D        0  Mon May 29 15:28:25 2017
  ..                                 DR        0  Mon May 29 14:48:01 2017
  xxx.txt                             A        0  Mon May 29 12:16:45 2017
  install.log                         A    54118  Mon May 29 15:28:25 2017
  passwd                                    1801  Mon May 29 12:02:13 2017

        39371 blocks of size 262144. 19964 blocks available
smb: \&gt; get xxx.txt 
getting file \xxx.txt of size 0 as xxx.txt (0.0 KiloBytes/sec) (average 0.0 KiloBytes/sec)
smb: \&gt; !ls
anaconda-ks.cfg  install.log  install.log.syslog  xxx.txt  公共的  模板  视频  图片  文档  下载  音乐  桌面
smb: \&gt; 
</code></pre></li>
</ul>
</li>
<li><p>使用mount挂载</p>
<pre><code>[root@m2lan170 ~]# mount -t cifs //192.168.0.150/shares /opt/ -o username=share2%123456
[root@m2lan170 ~]# mount | grep shares
//192.168.0.150/shares on /opt type cifs (rw)

[root@m2lan170 ~]# cd /opt/
[root@m2lan170 opt]# ls
install.log  passwd  test  xxx.txt
[root@m2lan170 opt]# touch b.txt
[root@m2lan170 opt]# ls
b.txt  install.log  passwd  test  xxx.txt
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下samba服务器配置实现文件共享&quot;&gt;&lt;a href=&quot;#Linux下samba服务器配置实现文件共享&quot; class=&quot;headerlink&quot; title=&quot;Linux下samba服务器配置实现文件共享&quot;&gt;&lt;/a&gt;Linux下samba服务器配置实现文件共享&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;samba可以在Linux系统和Windows系统之间进行通信，实现不同操作系统之间的资源共享。&lt;/p&gt;
&lt;p&gt;samba服务器端口号为139和445。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;install&quot;&gt;&lt;a href=&quot;#install&quot; class=&quot;headerlink&quot; title=&quot;install&quot;&gt;&lt;/a&gt;install&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在150服务器上安装samba服务端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# rpm -ivh /mnt/Packages/samba-3.6.9-164.el6.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在170服务器上安装samba客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan170 ~]# rpm -ivh /mnt/Packages/samba-client-3.6.9-164.el6.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;服务启动和关闭&quot;&gt;&lt;a href=&quot;#服务启动和关闭&quot; class=&quot;headerlink&quot; title=&quot;服务启动和关闭&quot;&gt;&lt;/a&gt;服务启动和关闭&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;samba服务器启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# /etc/init.d/smb start
||
[root@m2lan150 ~]# /etc/init.d/smb restart
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务配置重新加载，在不重启服务的情况下，加载配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# /etc/init.d/smb reload
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置开机自动启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# chkconfig smb on
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;查看端口号&quot;&gt;&lt;a href=&quot;#查看端口号&quot; class=&quot;headerlink&quot; title=&quot;查看端口号&quot;&gt;&lt;/a&gt;查看端口号&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# netstat -antup | grep smb
tcp        0      0 0.0.0.0:139                 0.0.0.0:*                   LISTEN      11677/smbd          
tcp        0      0 0.0.0.0:445                 0.0.0.0:*                   LISTEN      11677/smbd          
tcp        0      0 :::139                      :::*                        LISTEN      11677/smbd          
tcp        0      0 :::445                      :::*                        LISTEN      11677/smbd
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
      <category term="samba" scheme="http://blog.golearns.org/tags/samba/"/>
    
  </entry>
  
  <entry>
    <title>nfs服务配置</title>
    <link href="http://blog.golearns.org/2017/05/29/nfs%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.golearns.org/2017/05/29/nfs服务配置/</id>
    <published>2017-05-28T16:48:23.000Z</published>
    <updated>2017-05-28T16:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下nfs服务配置"><a href="#Linux下nfs服务配置" class="headerlink" title="Linux下nfs服务配置"></a>Linux下nfs服务配置</h1><blockquote>
<p>NFS是网络文件系统，允许一个系统在网络上与其他机器共享目录和文件</p>
<p>通过使用NFS，用户和程序可以像访问本地文件一样访问远程系统上的文件。 </p>
</blockquote>
<h3 id="启动150服务器的nfs服务"><a href="#启动150服务器的nfs服务" class="headerlink" title="启动150服务器的nfs服务"></a>启动150服务器的nfs服务</h3><pre><code>[root@m2lan150 ~]# service nfs start
启动 NFS 服务：                                            [确定]
关掉 NFS 配额：                                            [确定]
启动 NFS mountd：                                          [确定]
启动 NFS 守护进程：                                        [确定]
正在启动 RPC idmapd：                                      [确定]
</code></pre><h3 id="170服务器查看nfs服务器上所有共享目录"><a href="#170服务器查看nfs服务器上所有共享目录" class="headerlink" title="170服务器查看nfs服务器上所有共享目录"></a>170服务器查看nfs服务器上所有共享目录</h3><pre><code>[root@m2lan170 ~]# showmount -e 192.168.0.150
Export list for 192.168.0.150:
</code></pre><h3 id="150服务器共享-root-sh目录"><a href="#150服务器共享-root-sh目录" class="headerlink" title="150服务器共享/root/sh目录"></a>150服务器共享/root/sh目录</h3><pre><code># *表示所有客户端都可以访问，rw表示有读写权限
[root@m2lan150 ~]# cat /etc/exports 
/media *(rw)

# 重启nfs服务
[root@m2lan150 ~]# service nfs restart
关闭 NFS 守护进程：                                        [确定]
关闭 NFS mountd：                                          [确定]
关闭 NFS quotas：                                          [确定]
Shutting down RPC idmapd:                                  [确定]
启动 NFS 服务：                                            [确定]
关掉 NFS 配额：                                            [确定]
启动 NFS mountd：                                          [确定]
启动 NFS 守护进程：                                        [确定]
正在启动 RPC idmapd：                                      [确定]
</code></pre><a id="more"></a>
<h3 id="170服务器查看共享目录"><a href="#170服务器查看共享目录" class="headerlink" title="170服务器查看共享目录"></a>170服务器查看共享目录</h3><pre><code>[root@m2lan170 ~]# showmount -e 192.168.0.150
Export list for 192.168.0.150:
/media *

# 挂载
[root@m2lan170 ~]# mount 192.168.0.150:/media /opt/
# 在客户端创建文件，需要在服务端设置共享目录权限
[root@m2lan150 media]# chmod 777 /media/
# 客户端创建文件
[root@m2lan170 ~]# cd /opt/
[root@m2lan170 opt]# touch b.txt
[root@m2lan170 opt]# ls
a.txt  b.txt
[root@m2lan170 opt]# touch c.txt
[root@m2lan170 opt]# 
[root@m2lan170 opt]# ll
总用量 0
-rw-r--r-- 1 root      root      0 5月  28 23:28 a.txt
-rw-r--r-- 1 nfsnobody nfsnobody 0 5月  28 23:29 b.txt
-rw-r--r-- 1 nfsnobody nfsnobody 0 5月  28 23:29 c.txt
</code></pre><h3 id="开机自动挂在NFS文件系统"><a href="#开机自动挂在NFS文件系统" class="headerlink" title="开机自动挂在NFS文件系统"></a>开机自动挂在NFS文件系统</h3><pre><code>[root@m2lan170 opt]# cat /etc/fstab | grep media
192.168.0.150:/media    /opt                    nfs     defaults        0 0

# 取消挂载
[root@m2lan170 /]# umount /opt/

# 从/etc/fstab挂载所有内容
[root@m2lan170 /]# mount -a

# 查看
[root@m2lan170 /]# cd /opt/
[root@m2lan170 opt]# ls
a.txt
</code></pre><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td>所有客户端都可以访问</td>
</tr>
<tr>
<td style="text-align:center">rw</td>
<td>具有读写权限</td>
</tr>
<tr>
<td style="text-align:center">no_root_squash</td>
<td>如果用root登录nfs，使其身份就是root</td>
</tr>
<tr>
<td style="text-align:center">sync</td>
<td>同步，数据同步写入磁盘</td>
</tr>
<tr>
<td style="text-align:center">async</td>
<td>异步，先写入内存，异步写入磁盘</td>
</tr>
<tr>
<td style="text-align:center">ro</td>
<td>只读</td>
</tr>
<tr>
<td style="text-align:center">all_squash</td>
<td>用户登录nfs时，指定身份为UID/GID的用户</td>
</tr>
<tr>
<td style="text-align:center">root_squash</td>
<td>如果用root登录nfs，使其身份自动换成nfsbody</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*(rw)</td>
<td>所有用户</td>
</tr>
<tr>
<td>*(rw,root_squash)</td>
<td>所有用户</td>
</tr>
<tr>
<td>*(rw,no_root_squash)</td>
<td>所有用户</td>
</tr>
<tr>
<td>192.168.1.0/24(rw,sync)</td>
<td>指定IP段</td>
</tr>
<tr>
<td>192.168.1.150(ro)</td>
<td>指定IP</td>
</tr>
<tr>
<td>192.168.1.0/255.255.255.0(async)</td>
<td>指定IP段</td>
</tr>
<tr>
<td>192.168.1.0/255.255.255.0(rw) 192.168.2.0/255.255.255.0(rw)</td>
<td>指定多个IP段</td>
</tr>
<tr>
<td>*.m2lan.com(rw,all_squash,anonuid=500,anongid=500)</td>
<td>指定域名</td>
</tr>
</tbody>
</table>
<h3 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h3><ul>
<li><p>autofs软件包要实现自动挂载涉及到两个文件，auto.master和auto.misc</p>
<ul>
<li>/etc/auto.master定义本地挂载点</li>
<li>/etc/auto.misc配置文件是用来设置需要挂载的文件系统类型和选项</li>
</ul>
</li>
<li><p>配置</p>
<pre><code># 添加/opt /etc/auto.nfs，设置挂载点为/opt
# /etc/auto.nfs设置需要挂在的文件系统类型和选项
# --timout=60 当超过60s没有访问则自动卸载
[root@m2lan170 ~]# cat /etc/auto.master | grep -v &apos;^#&apos; | grep -v &apos;^$&apos;
/misc    /etc/auto.misc
/opt    /etc/auto.nfs --timeout=60
/net    -hosts
+auto.master

# 手动创建
[root@m2lan170 ~]# vim /etc/auto.nfs

# /etc/auto.nfs
# nfs是触发的条件，当cd进入到/opt/nfs目录时系统会自动将远程的/media挂载
# nfs目录不能提前创建，自动挂载的时候会自动创建
# -fstype文件系统类型为nfs
[root@m2lan170 ~]# cat /etc/auto.nfs
nfs -fstype=nfs 192.168.0.150:/media

# 重启autofs
[root@m2lan170 ~]# service autofs restart
停止 automount：                                           [确定]
正在启动 automount：                                       [确定]

# 当访问/opt/nfs路径的时候，会自动挂载上
[root@m2lan170 ~]# cd /opt/nfs
[root@m2lan170 nfs]# ls
a.txt  b.txt  c.txt  d.txt

# 查看挂载
[root@m2lan170 nfs]# mount | grep /media
192.168.0.150:/media on /opt/nfs type nfs (rw,vers=4,addr=192.168.0.150,clientaddr=192.168.0.170)
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下nfs服务配置&quot;&gt;&lt;a href=&quot;#Linux下nfs服务配置&quot; class=&quot;headerlink&quot; title=&quot;Linux下nfs服务配置&quot;&gt;&lt;/a&gt;Linux下nfs服务配置&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;NFS是网络文件系统，允许一个系统在网络上与其他机器共享目录和文件&lt;/p&gt;
&lt;p&gt;通过使用NFS，用户和程序可以像访问本地文件一样访问远程系统上的文件。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;启动150服务器的nfs服务&quot;&gt;&lt;a href=&quot;#启动150服务器的nfs服务&quot; class=&quot;headerlink&quot; title=&quot;启动150服务器的nfs服务&quot;&gt;&lt;/a&gt;启动150服务器的nfs服务&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# service nfs start
启动 NFS 服务：                                            [确定]
关掉 NFS 配额：                                            [确定]
启动 NFS mountd：                                          [确定]
启动 NFS 守护进程：                                        [确定]
正在启动 RPC idmapd：                                      [确定]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;170服务器查看nfs服务器上所有共享目录&quot;&gt;&lt;a href=&quot;#170服务器查看nfs服务器上所有共享目录&quot; class=&quot;headerlink&quot; title=&quot;170服务器查看nfs服务器上所有共享目录&quot;&gt;&lt;/a&gt;170服务器查看nfs服务器上所有共享目录&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[root@m2lan170 ~]# showmount -e 192.168.0.150
Export list for 192.168.0.150:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;150服务器共享-root-sh目录&quot;&gt;&lt;a href=&quot;#150服务器共享-root-sh目录&quot; class=&quot;headerlink&quot; title=&quot;150服务器共享/root/sh目录&quot;&gt;&lt;/a&gt;150服务器共享/root/sh目录&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# *表示所有客户端都可以访问，rw表示有读写权限
[root@m2lan150 ~]# cat /etc/exports 
/media *(rw)

# 重启nfs服务
[root@m2lan150 ~]# service nfs restart
关闭 NFS 守护进程：                                        [确定]
关闭 NFS mountd：                                          [确定]
关闭 NFS quotas：                                          [确定]
Shutting down RPC idmapd:                                  [确定]
启动 NFS 服务：                                            [确定]
关掉 NFS 配额：                                            [确定]
启动 NFS mountd：                                          [确定]
启动 NFS 守护进程：                                        [确定]
正在启动 RPC idmapd：                                      [确定]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
      <category term="NFS" scheme="http://blog.golearns.org/tags/NFS/"/>
    
  </entry>
  
  <entry>
    <title>dhcp服务动态分配IP地址</title>
    <link href="http://blog.golearns.org/2017/05/28/dhcp%E6%9C%8D%E5%8A%A1%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP%E5%9C%B0%E5%9D%80/"/>
    <id>http://blog.golearns.org/2017/05/28/dhcp服务动态分配IP地址/</id>
    <published>2017-05-28T10:46:20.000Z</published>
    <updated>2017-05-28T10:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下使用dhcp服务动态分配IP地址"><a href="#Linux下使用dhcp服务动态分配IP地址" class="headerlink" title="Linux下使用dhcp服务动态分配IP地址"></a>Linux下使用dhcp服务动态分配IP地址</h1><blockquote>
<p>动态主机配置协议</p>
</blockquote>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><ul>
<li><p>使用yum安装</p>
<pre><code>[root@m2lan150 ~]# yum install -y dhcp
</code></pre></li>
<li><p>查看包的安装路径</p>
<pre><code>[root@m2lan150 ~]# rpm -pql /mnt/Packages/dhcp-4.1.1-38.P1.el6.x86_64.rpm | more
</code></pre></li>
<li><p>备份配置文件</p>
<pre><code>[root@m2lan150 ~]# cp /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.bak
</code></pre></li>
<li><p>查看配置文件</p>
<pre><code>[root@m2lan150 ~]# cat /etc/dhcp/dhcpd.conf
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.sample
#   see &apos;man 5 dhcpd.conf&apos;
#
</code></pre></li>
<li><p>copy配置示例配置文件覆盖当前配置文件</p>
<pre><code>[root@m2lan150 ~]# cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="修改vmware网络链接"><a href="#修改vmware网络链接" class="headerlink" title="修改vmware网络链接"></a>修改vmware网络链接</h3><ul>
<li>设置150和170服务器
<img src="http://oqnqa6hhs.bkt.clouddn.com/vmware-network.png" alt=""></li>
</ul>
<h3 id="dhcp配置"><a href="#dhcp配置" class="headerlink" title="dhcp配置"></a>dhcp配置</h3><ul>
<li><p>150服务器配置，删除其他的subnet，只保留下面一个</p>
<pre><code>subnet 192.168.1.0 netmask 255.255.255.0 {
  # 可以分配网段的范围100-200
  range 192.168.1.100 192.168.1.200;
  # DNS为192.168.1.1
  option domain-name-servers 192.168.1.1;
  # 为客户端指定所属的域
  option domain-name &quot;internal.example.org&quot;;
  # 默认网关
  option routers 192.168.1.1;
  # 广播地址
  option broadcast-address 192.168.1.255;
  # 定义默认IP租约时间，以秒为单位
  default-lease-time 600;
  # 客户端租约时间最大值，当客户端超过租约时间，尚未更新IP地址时，所能使用该IP的最大时间
  max-lease-time 7200;
}
</code></pre></li>
</ul>
<h3 id="设置150服务器网络配置"><a href="#设置150服务器网络配置" class="headerlink" title="设置150服务器网络配置"></a>设置150服务器网络配置</h3><ul>
<li><p>配置文件</p>
<pre><code>[root@m2lan150 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0
TYPE=Ethernet
UUID=66cce682-8059-4f3e-b8e4-29a171e3bfaf
ONBOOT=yes
NM_CONTROLLED=yes
BOOTPROTO=none
IPADDR=192.168.1.150
PREFIX=24
GATEWAY=192.168.1.1
#DNS1=192.168.0.1
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=no
NAME=&quot;System eth0&quot;
</code></pre></li>
<li><p>重启network</p>
<pre><code>[root@m2lan150 ~]# service network restart
正在关闭接口 eth0：                                        [确定]
关闭环回接口：                                             [确定]
弹出环回接口：                                             [确定]
弹出界面 eth0： Determining if ip address 192.168.1.150 is already in use for device eth0...
                                                           [确定]
</code></pre></li>
</ul>
<h3 id="启动dhcp服务"><a href="#启动dhcp服务" class="headerlink" title="启动dhcp服务"></a>启动dhcp服务</h3><pre><code>[root@m2lan150 ~]# service dhcpd restart
正在启动 dhcpd：                                           [确定]
</code></pre><h3 id="查看dns"><a href="#查看dns" class="headerlink" title="查看dns"></a>查看dns</h3><pre><code>[root@m2lan150 ~]# cat /etc/resolv.conf 
# Generated by NetworkManager
search 192.168.1.1 com
nameserver 192.168.1.1
</code></pre><h3 id="设置170服务器网络链接方式为dhcp"><a href="#设置170服务器网络链接方式为dhcp" class="headerlink" title="设置170服务器网络链接方式为dhcp"></a>设置170服务器网络链接方式为dhcp</h3><ul>
<li><p>配置文件</p>
<pre><code>[root@m2lan170 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0
TYPE=Ethernet
UUID=7f42e98a-1a5a-487f-aafc-f98566add268
ONBOOT=yes
NM_CONTROLLED=yes
BOOTPROTO=dhcp
PREFIX=24
#DNS1=192.168.0.1
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=no
NAME=&quot;System eth0&quot;
HWADDR=00:0c:29:09:2f:33
USERCTL=no
PEERDNS=yes
</code></pre></li>
<li><p>重启network</p>
<pre><code>[root@m2lan170 ~]# service network restart
正在关闭接口 eth0： 设备状态：3 (断开连接)
                                                           [确定]
关闭环回接口：                                             [确定]
弹出环回接口：                                             [确定]
弹出界面 eth0： 活跃连接状态：激活中
活跃连接路径：/org/freedesktop/NetworkManager/ActiveConnection/8
状态：激活的
连接被激活
                                                           [确定]
</code></pre></li>
<li><p>查看IP地址</p>
<pre><code>[root@m2lan170 ~]# ifconfig eth0
  eth0      Link encap:Ethernet  HWaddr 00:0C:29:09:2F:33  
  inet addr:192.168.1.100  Bcast:192.168.1.255  Mask:255.255.255.0
  inet6 addr: fe80::20c:29ff:fe09:2f33/64 Scope:Link
  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
  RX packets:13590 errors:0 dropped:0 overruns:0 frame:0
  TX packets:7691 errors:0 dropped:0 overruns:0 carrier:0
  collisions:0 txqueuelen:1000 
  RX bytes:1127345 (1.0 MiB)  TX bytes:674880 (659.0 KiB)
</code></pre></li>
</ul>
<h3 id="使用150服务器连接"><a href="#使用150服务器连接" class="headerlink" title="使用150服务器连接"></a>使用150服务器连接</h3><pre><code>[root@m2lan150 ~]# ssh 192.168.1.100
The authenticity of host &apos;192.168.1.100 (192.168.1.100)&apos; can&apos;t be established.
RSA key fingerprint is f1:37:53:b9:f2:7a:d0:35:4a:ee:f8:82:ed:1c:6a:18.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &apos;192.168.1.100&apos; (RSA) to the list of known hosts.
Last login: Sun May 28 11:31:55 2017 from m2lan150.com
[root@m2lan170 ~]# exit
logout
Connection to 192.168.1.100 closed.
</code></pre><h3 id="使用dhcp为170服务器分配静态IP地址"><a href="#使用dhcp为170服务器分配静态IP地址" class="headerlink" title="使用dhcp为170服务器分配静态IP地址"></a>使用dhcp为170服务器分配静态IP地址</h3><ul>
<li><p>获取170服务器的mac地址</p>
<pre><code>[root@m2lan170 ~]# ip addr show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:09:2f:33 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
    inet6 fe80::20c:29ff:fe09:2f33/64 scope link 
       valid_lft forever preferred_lft forever
</code></pre></li>
<li><p>修改150服务器dhcp配置</p>
<pre><code>subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.100 192.168.1.200;
  option domain-name-servers 192.168.1.1;
  option domain-name &quot;internal.example.org&quot;;
  option routers 192.168.1.1;
  option broadcast-address 192.168.1.255;
  default-lease-time 600;
  max-lease-time 7200;

  host m2lan170 {
     hardware ethernet 00:0c:29:09:2f:33;
     fixed-address 192.168.1.170;
  }
}
</code></pre></li>
<li><p>重启dhcp</p>
<pre><code>[root@m2lan150 ~]# service dhcpd restart
关闭 dhcpd：                                               [确定]
正在启动 dhcpd：                                           [确定]
</code></pre></li>
<li><p>重启170服务器network</p>
</li>
<li><p>查看170服务器的IP地址</p>
<pre><code>[root@m2lan170 ~]# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:0C:29:09:2F:33  
          inet addr:192.168.1.170  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe09:2f33/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:13964 errors:0 dropped:0 overruns:0 frame:0
          TX packets:7938 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:1164135 (1.1 MiB)  TX bytes:703980 (687.4 KiB)
</code></pre></li>
</ul>
<h3 id="查看租约文件"><a href="#查看租约文件" class="headerlink" title="查看租约文件"></a>查看租约文件</h3><pre><code>[root@m2lan150 ~]# cat /var/lib/dhcpd/dhcpd.leases
# The format of this file is documented in the dhcpd.leases(5) manual page.
# This lease file was written by isc-dhcp-4.1.1-P1

lease 192.168.1.100 {
  starts 0 2017/05/28 10:23:22;
  ends 0 2017/05/28 10:33:22;
  tstp 0 2017/05/28 10:33:22;
  cltt 0 2017/05/28 10:23:22;
  binding state active;
  next binding state free;
  hardware ethernet 00:0c:29:09:2f:33;
  client-hostname &quot;m2lan170.com&quot;;
}
server-duid &quot;\000\001\000\001 \275Z\263\000\014)%_\241&quot;;

lease 192.168.1.100 {
  starts 0 2017/05/28 10:23:22;
  ends 0 2017/05/28 10:33:22;
  tstp 0 2017/05/28 10:33:22;
  cltt 0 2017/05/28 10:23:22;
  binding state free;
  hardware ethernet 00:0c:29:09:2f:33;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下使用dhcp服务动态分配IP地址&quot;&gt;&lt;a href=&quot;#Linux下使用dhcp服务动态分配IP地址&quot; class=&quot;headerlink&quot; title=&quot;Linux下使用dhcp服务动态分配IP地址&quot;&gt;&lt;/a&gt;Linux下使用dhcp服务动态分配IP地址&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;动态主机配置协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;install&quot;&gt;&lt;a href=&quot;#install&quot; class=&quot;headerlink&quot; title=&quot;install&quot;&gt;&lt;/a&gt;install&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用yum安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# yum install -y dhcp
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看包的安装路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# rpm -pql /mnt/Packages/dhcp-4.1.1-38.P1.el6.x86_64.rpm | more
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;备份配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# cp /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.bak
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# cat /etc/dhcp/dhcpd.conf
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.sample
#   see &amp;apos;man 5 dhcpd.conf&amp;apos;
#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;copy配置示例配置文件覆盖当前配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
      <category term="dhcp" scheme="http://blog.golearns.org/tags/dhcp/"/>
    
  </entry>
  
  <entry>
    <title>sshd服务防暴力破解</title>
    <link href="http://blog.golearns.org/2017/05/28/sshd%E6%9C%8D%E5%8A%A1%E9%98%B2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <id>http://blog.golearns.org/2017/05/28/sshd服务防暴力破解/</id>
    <published>2017-05-28T05:16:07.000Z</published>
    <updated>2017-05-28T05:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下sshd服务防暴力破解"><a href="#Linux下sshd服务防暴力破解" class="headerlink" title="Linux下sshd服务防暴力破解"></a>Linux下sshd服务防暴力破解</h1><blockquote>
<p>网站被暴力破解sshd服务密码，虽然没有成功，但会导致系统负载很高。</p>
<p>原因是在暴力破解的时候，系统会不断认证用户，增加了系统资源的开销，导致网站访问速度很慢。</p>
<p>fail2ban可以监视系统日志，然后匹配日志的错误信息执行屏蔽动作。</p>
</blockquote>
<h3 id="lastb"><a href="#lastb" class="headerlink" title="lastb"></a>lastb</h3><ul>
<li><p>使用lastb命令，可以列出登入系统失败的用户信息</p>
<pre><code>[root@m2lan150 ~]# lastb
M2       ssh:notty    192.168.0.102    Sun May 28 12:17 - 12:17  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 12:17 - 12:17  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 12:17 - 12:17  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 11:39 - 11:39  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 11:39 - 11:39  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 11:39 - 11:39  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 11:39 - 11:39  (00:00)    
root     tty1         :0               Sat May 27 21:57 - 21:57  (00:00)    

btmp begins Sat May 27 21:57:36 2017
</code></pre></li>
</ul>
<h3 id="下载fail2ban"><a href="#下载fail2ban" class="headerlink" title="下载fail2ban"></a>下载fail2ban</h3><ul>
<li><a href="https://github.com/fail2ban/fail2ban/archive/0.8.14.tar.gz" target="_blank" rel="external">fail2ban</a></li>
<li><p>解压并安装</p>
<pre><code>[root@m2lan150 ~]# tar -xzvf fail2ban-0.8.14.tar.gz
[root@m2lan150 ~]# cd fail2ban-0.8.14
[root@m2lan150 fail2ban-0.8.14]# python setup.py install
# 查找启动文件
[root@m2lan150 fail2ban-0.8.14]# grep chkconfig ./* -R --color
./files/redhat-initd:# chkconfig: - 92 08
# copy启动文件
[root@m2lan150 fail2ban-0.8.14]# cp files/redhat-initd /etc/init.d/fail2ban
# 设置开机启动
[root@m2lan150 fail2ban-0.8.14]# chkconfig --add fail2ban
</code></pre></li>
</ul>
<a id="more"></a>
<ul>
<li>fail2ban文件说明<code>ll /etc/fail2ban/</code></li>
</ul>
<table>
<thead>
<tr>
<th>文件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>action.d</td>
<td>动作文件，内含默认文件。iptables以及mail等动作配置</td>
</tr>
<tr>
<td>fail2ban.conf</td>
<td>定义了fail2ban日志级别、日志位置及sock文件位置</td>
</tr>
<tr>
<td>filter.d</td>
<td>条件文件夹，内含默认文件。过滤日志关键内容设置</td>
</tr>
<tr>
<td>jail.conf</td>
<td>主要配置文件，模块化。主要设置启动ban动作的服务及动作阈值</td>
</tr>
</tbody>
</table>
<h3 id="使用fail2ban限制用户登陆"><a href="#使用fail2ban限制用户登陆" class="headerlink" title="使用fail2ban限制用户登陆"></a>使用fail2ban限制用户登陆</h3><blockquote>
<p>ssh远程登陆5分钟内3次密码验证失败，禁止用户IP访问主机1小时，1小时后限制解除，可以登陆主机。</p>
</blockquote>
<ul>
<li><p>使用的配置文件</p>
<pre><code>[root@m2lan150 fail2ban]# ll action.d/iptables.conf 
-rw-rw-r-- 1 root root 1838 8月  20 2014 action.d/iptables.conf
[root@m2lan150 fail2ban]# ll filter.d/sshd.conf 
-rw-rw-r-- 1 root root 1816 8月  20 2014 filter.d/sshd.conf
[root@m2lan150 fail2ban]# ll jail.conf 
-rw-rw-r-- 1 root root 19316 8月  20 2014 jail.conf
</code></pre></li>
<li><p>jail.conf配置文件说明</p>
<pre><code># 全局配置
[DEFAULT]
# 忽略的IP列表，不受限制
ignoreip = 127.0.0.1/8
# 屏蔽时间，秒
bantime  = 600
# 在findtime时间内超过maxretry次就会被屏蔽，屏蔽bantime秒
findtime  = 600
# 最大尝试次数
maxretry = 3
# 屏蔽时间过了后自动恢复登陆
backend = auto

# 单个服务配置，如果bantime、findtime、maxretry和全局配置冲突
# 服务优先级大于全局配置
[ssh-iptables]
# 服务是否启用，设置为true
enabled  = true
# 过滤规则filter的名字，对应filter.d/sshd.conf
filter   = sshd
# 动作相关参数，对应action.d/iptables.conf
# 触发报警的收件人
action   = iptables[name=SSH, port=ssh, protocol=tcp]
           sendmail-whois[name=SSH, dest=you@example.com, sender=fail2ban@example.com, sendername=&quot;Fail2Ban&quot;]
# 日志存放位置，设置为sshd的日志文件/var/log/secure，默认为/var/log/sshd.log
logpath  = /var/log/secure
# 5分钟内3次密码验证失败，禁止用户IP访问主机1小时，配置：
bantime  = 3600
findtime  = 300
maxretry = 3
</code></pre></li>
<li><p>启动服务</p>
<pre><code># 清空日志文件
[root@m2lan150 fail2ban]# &gt; /var/log/secure
# 启动fail2ban
[root@m2lan150 fail2ban]# /etc/init.d/fail2ban start
启动fail2ban:                                              [确定]
# iptables配置中会多出一个fail2ban-SSH
[root@m2lan150 fail2ban]# iptables -L -n
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
fail2ban-SSH  tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22 

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

Chain fail2ban-SSH (1 references)
target     prot opt source               destination         
RETURN     all  --  0.0.0.0/0            0.0.0.0/0

# 使用其他机器登陆150服务器测试
M2@zhuyongkangdeMacBook-Pro  ~  ssh 192.168.0.150
The authenticity of host &apos;192.168.0.150 (192.168.0.150)&apos; can&apos;t be established. 
RSA key fingerprint is SHA2560RjnF0jVdr3FnSdLx+OQzkzAmJ4xD8O9ZwzQL+Gp+E. 
Are you sure you want to continue connecting (yes/no)? yes 
Warning: Permanently added &apos;192.168.0.150&apos; (RSA) to the list of known hosts. M2@192.168.0.150&apos;s password: 
Permission denied, please try again. 
M2@192.168.0.150&apos;s password: 
Permission denied, please try again. 
M2@192.168.0.150&apos;s password: 
Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password). 
# 当尝试3次登陆失败后，再次登陆直接被拒绝
M2@zhuyongkangdeMacBook-Pro  ~  ssh 192.168.0.150 
ssh: connect to host 192.168.0.150 port 22: Connection refused
# 查看iptables
[root@m2lan150 fail2ban]# iptables -L -n
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
fail2ban-SSH  tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22 

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

Chain fail2ban-SSH (1 references)
target     prot opt source               destination         
REJECT     all  --  192.168.0.102        0.0.0.0/0           reject-with icmp-port-unreachable 
RETURN     all  --  0.0.0.0/0            0.0.0.0/0
</code></pre></li>
</ul>
<h3 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h3><ul>
<li><p>查看所有服务状态</p>
<pre><code>[root@m2lan150 fail2ban]# fail2ban-client status
Status
|- Number of jail:    1
`- Jail list:        ssh-iptables
</code></pre></li>
<li><p>查看指定服务状态</p>
<ul>
<li><code>Currently banned</code>: 当前拒绝的IP数</li>
<li><p><code>Total banned</code>: 总共拒绝的IP数</p>
<pre><code>[root@m2lan150 fail2ban]# fail2ban-client status ssh-iptables
Status for the jail: ssh-iptables
|- filter
|  |- File list:    /var/log/secure 
|  |- Currently failed:    1
|  `- Total failed:    4
`- action
   |- Currently banned:    1
   |  `- IP list:    192.168.0.102 
   `- Total banned:    1
</code></pre></li>
</ul>
</li>
<li><p>查看fail2ban日志文件</p>
<ul>
<li>Ban锁定了192.168.0.102IP</li>
<li><p>10分钟后解除锁定Unban </p>
<pre><code>[root@m2lan150 fail2ban]# tail /var/log/fail2ban.log 
2017-05-28 11:27:39,995 fail2ban.jail   [5280]: INFO    Creating new jail &apos;ssh-iptables&apos;
2017-05-28 11:27:40,008 fail2ban.jail   [5280]: INFO    Jail &apos;ssh-iptables&apos; uses Gamin
2017-05-28 11:27:40,076 fail2ban.jail   [5280]: INFO    Initiated &apos;gamin&apos; backend
2017-05-28 11:27:40,102 fail2ban.filter [5280]: INFO    Added logfile = /var/log/secure
2017-05-28 11:27:40,104 fail2ban.filter [5280]: INFO    Set maxRetry = 3
2017-05-28 11:27:40,106 fail2ban.filter [5280]: INFO    Set findtime = 300
2017-05-28 11:27:40,106 fail2ban.actions[5280]: INFO    Set banTime = 600
2017-05-28 11:27:40,279 fail2ban.jail   [5280]: INFO    Jail &apos;ssh-iptables&apos; started
2017-05-28 11:39:18,897 fail2ban.actions[5280]: WARNING [ssh-iptables] Ban 192.168.0.102
2017-05-28 11:49:19,016 fail2ban.actions[5280]: WARNING [ssh-iptables] Unban 192.168.0.102
</code></pre></li>
</ul>
</li>
<li><p>解除屏蔽,清空日志文件</p>
<pre><code># 清空日志文件
[root@m2lan150 ~]# &gt; /var/log/secure
# 重新启动后使用被屏蔽的IP再次登陆
[root@m2lan150 ~]# /etc/init.d/fail2ban restart
关闭fail2ban:                                              [确定]
启动fail2ban:                                              [确定]
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下sshd服务防暴力破解&quot;&gt;&lt;a href=&quot;#Linux下sshd服务防暴力破解&quot; class=&quot;headerlink&quot; title=&quot;Linux下sshd服务防暴力破解&quot;&gt;&lt;/a&gt;Linux下sshd服务防暴力破解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;网站被暴力破解sshd服务密码，虽然没有成功，但会导致系统负载很高。&lt;/p&gt;
&lt;p&gt;原因是在暴力破解的时候，系统会不断认证用户，增加了系统资源的开销，导致网站访问速度很慢。&lt;/p&gt;
&lt;p&gt;fail2ban可以监视系统日志，然后匹配日志的错误信息执行屏蔽动作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;lastb&quot;&gt;&lt;a href=&quot;#lastb&quot; class=&quot;headerlink&quot; title=&quot;lastb&quot;&gt;&lt;/a&gt;lastb&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用lastb命令，可以列出登入系统失败的用户信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# lastb
M2       ssh:notty    192.168.0.102    Sun May 28 12:17 - 12:17  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 12:17 - 12:17  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 12:17 - 12:17  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 11:39 - 11:39  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 11:39 - 11:39  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 11:39 - 11:39  (00:00)    
M2       ssh:notty    192.168.0.102    Sun May 28 11:39 - 11:39  (00:00)    
root     tty1         :0               Sat May 27 21:57 - 21:57  (00:00)    

btmp begins Sat May 27 21:57:36 2017
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;下载fail2ban&quot;&gt;&lt;a href=&quot;#下载fail2ban&quot; class=&quot;headerlink&quot; title=&quot;下载fail2ban&quot;&gt;&lt;/a&gt;下载fail2ban&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fail2ban/fail2ban/archive/0.8.14.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fail2ban&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压并安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# tar -xzvf fail2ban-0.8.14.tar.gz
[root@m2lan150 ~]# cd fail2ban-0.8.14
[root@m2lan150 fail2ban-0.8.14]# python setup.py install
# 查找启动文件
[root@m2lan150 fail2ban-0.8.14]# grep chkconfig ./* -R --color
./files/redhat-initd:# chkconfig: - 92 08
# copy启动文件
[root@m2lan150 fail2ban-0.8.14]# cp files/redhat-initd /etc/init.d/fail2ban
# 设置开机启动
[root@m2lan150 fail2ban-0.8.14]# chkconfig --add fail2ban
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="ssh" scheme="http://blog.golearns.org/tags/ssh/"/>
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用操作</title>
    <link href="http://blog.golearns.org/2017/05/28/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://blog.golearns.org/2017/05/28/Linux常用操作/</id>
    <published>2017-05-27T17:06:33.000Z</published>
    <updated>2017-05-28T05:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h1><ul>
<li><p>清空iptables</p>
<pre><code>[root@m2 ~]# iptables -F
[root@m2 ~]# /etc/init.d/iptables save
iptables：将防火墙规则保存到 /etc/sysconfig/iptables：     [确定]
</code></pre></li>
<li><p>关闭selinux</p>
<pre><code>[root@m2 ~]# vim /etc/selinux/config
SELINUX=disabled
</code></pre></li>
<li><p>查看selinux是否关闭</p>
<pre><code>[root@m2 ~]# getenforce
Disabled
</code></pre></li>
<li><p>配置永久主机名</p>
<pre><code>[root@m2lan150 ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=m2lan150.com
</code></pre></li>
</ul>
<a id="more"></a>
<ul>
<li><p>磁盘挂载</p>
<pre><code>[root@m2lan150 ~]# mount /dev/cdrom /mnt/
</code></pre></li>
<li><p>磁盘开机自动挂载</p>
<pre><code>[root@m2lan150 ~]# cat /etc/fstab | grep /cdrom
/dev/cdrom        /mnt            iso9660 defaults    0 0
</code></pre></li>
<li><p>配置yum源</p>
<pre><code>[root@m2lan150 ~]# cat /etc/yum.repos.d/rhel-source.repo
[rhel-source]
name=Red Hat Enterprise Linux $releasever - $basearch - Source
baseurl=file:///mnt/
enabled=1
gpgcheck=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release

# 清除缓存
[root@m2lan150 ~]# yum clean all

# 重新生成
[root@m2lan150 ~]# yum list
</code></pre></li>
<li><p>克隆虚拟机出现<code>设备 eth0 似乎不存在, 初始化操作将被延迟。</code>错误</p>
<pre><code># 删除配置文件的HWADDR
[root@m2lan150 ~]# cat !$
cat /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
TYPE=Ethernet
UUID=66cce682-8059-4f3e-b8e4-29a171e3bfaf
ONBOOT=yes
NM_CONTROLLED=yes
BOOTPROTO=none
IPADDR=192.168.0.150
PREFIX=24
GATEWAY=192.168.0.1
DNS1=192.168.0.1
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=no
NAME=&quot;System eth0&quot;
# 删除/etc/udev/rules.d/70-persistent-net.rules文件
[root@m2lan150 ~]# rm -f /etc/udev/rules.d/70-persistent-net.rules

# 重启
[root@m2lan150 ~]# reboot
</code></pre></li>
<li><p>开机启动</p>
<pre><code># 设置sshd开机启动
[root@m2lan150 ~]# chkconfig sshd on

# 查看启动级别
[root@m2lan150 ~]# chkconfig --list sshd
sshd               0:关闭    1:关闭    2:启用    3:启用    4:启用    5:启用    6:关闭
</code></pre></li>
<li><p>服务器端口嗅探工具</p>
<pre><code># 安装nmap
[root@m2lan150 ~]# rpm -ivh /mnt/Packages/nmap-5.51-3.el6.x86_64.rpm

# 将170服务器的sshd端口修改为222
[root@m2lan170 ~]# cat /etc/ssh/sshd_config | grep Port
#Port 22
Port 222
#GatewayPorts no

# 在150服务器上查看170服务器开放端口
[root@m2lan150 ~]# nmap m2lan170.com

Starting Nmap 5.51 ( http://nmap.org ) at 2017-05-27 23:30 CST
Nmap scan report for m2lan170.com (192.168.0.170)
Host is up (0.000093s latency).
Not shown: 998 closed ports
PORT    STATE SERVICE
111/tcp open  rpcbind
222/tcp open  rsh-spx
MAC Address: 00:0C:29:09:2F:33 (VMware)

Nmap done: 1 IP address (1 host up) scanned in 0.14 seconds
</code></pre></li>
<li><p>查看服务端口</p>
<pre><code>/etc/services
# 查看rsync服务端口
[root@m2lan150 ~]# cat /etc/services | grep rsync
rsync           873/tcp                         # rsync
rsync           873/udp                         # rsync
airsync         2175/tcp                # Microsoft Desktop AirSync Protocol
airsync         2175/udp                # Microsoft Desktop AirSync Protocol
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux常用操作&quot;&gt;&lt;a href=&quot;#Linux常用操作&quot; class=&quot;headerlink&quot; title=&quot;Linux常用操作&quot;&gt;&lt;/a&gt;Linux常用操作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;清空iptables&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2 ~]# iptables -F
[root@m2 ~]# /etc/init.d/iptables save
iptables：将防火墙规则保存到 /etc/sysconfig/iptables：     [确定]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关闭selinux&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2 ~]# vim /etc/selinux/config
SELINUX=disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看selinux是否关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2 ~]# getenforce
Disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置永久主机名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=m2lan150.com
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>sshd服务管理</title>
    <link href="http://blog.golearns.org/2017/05/28/sshd%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.golearns.org/2017/05/28/sshd服务管理/</id>
    <published>2017-05-27T17:03:56.000Z</published>
    <updated>2017-05-27T17:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下SSHD服务管理"><a href="#Linux下SSHD服务管理" class="headerlink" title="Linux下SSHD服务管理"></a>Linux下SSHD服务管理</h1><blockquote>
<p>sshd服务使用SSH协议进行远程控制，或在计算机之间传输文件</p>
</blockquote>
<h3 id="设置sshd端口"><a href="#设置sshd端口" class="headerlink" title="设置sshd端口"></a>设置sshd端口</h3><ul>
<li><p>将170服务器的sshd端口修改为222</p>
<pre><code>[root@m2lan170 ~]# cat /etc/ssh/sshd_config | grep Port | grep -v &apos;^#&apos;
Port 222
</code></pre></li>
</ul>
<h3 id="设置sshd访问IP地址"><a href="#设置sshd访问IP地址" class="headerlink" title="设置sshd访问IP地址"></a>设置sshd访问IP地址</h3><ul>
<li><p>只允许192.168.0.170服务器登陆</p>
<pre><code>[root@m2lan150 ~]# cat /etc/ssh/sshd_config | grep ListenAddress | grep -v &apos;^#&apos;
ListenAddress 192.168.0.170

[root@m2lan150 ~]# /etc/init.d/sshd restart
</code></pre></li>
</ul>
<h3 id="日志存放位置"><a href="#日志存放位置" class="headerlink" title="日志存放位置"></a>日志存放位置</h3><ul>
<li><p>查看日志级别</p>
<pre><code>[root@m2lan150 ~]# cat /etc/ssh/sshd_config | grep Syslog | grep -v &apos;^#&apos;
SyslogFacility AUTHPRIV
</code></pre></li>
<li><p>查看日志存放位置</p>
<pre><code>[root@m2lan150 ~]# cat /etc/rsyslog.conf | grep ^authpriv
authpriv.*                                              /var/log/secure
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="设置不允许root账户登陆"><a href="#设置不允许root账户登陆" class="headerlink" title="设置不允许root账户登陆"></a>设置不允许root账户登陆</h3><ul>
<li><p>将PermitRootLogin设置为no</p>
<pre><code>[root@m2lan150 ~]# cat /etc/ssh/sshd_config | grep RootLogin | grep -v &apos;^#&apos;
PermitRootLogin no
</code></pre></li>
</ul>
<h3 id="如果用户不能在指定时间内登陆服务器，则断开"><a href="#如果用户不能在指定时间内登陆服务器，则断开" class="headerlink" title="如果用户不能在指定时间内登陆服务器，则断开"></a>如果用户不能在指定时间内登陆服务器，则断开</h3><ul>
<li><p>表示在5s内不能成功登陆，就断开。LoginGraceTime单位默认为秒</p>
<pre><code>[root@m2lan170 ~]# cat /etc/ssh/sshd_config | grep LoginGrace | grep -v &apos;^#&apos;
LoginGraceTime 5
</code></pre></li>
</ul>
<h3 id="使用密钥登陆"><a href="#使用密钥登陆" class="headerlink" title="使用密钥登陆"></a>使用密钥登陆</h3><ul>
<li><p>在170服务器生成密钥</p>
<pre><code>[root@m2lan170 ~]# ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
/root/.ssh/id_rsa already exists.
Overwrite (y/n)? y
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
b2:26:0f:de:6e:c8:a1:b5:8e:e3:7b:5a:91:0e:22:83 root@m2lan170.com
The key&apos;s randomart image is:
+--[ RSA 2048]----+
|                 |
|                 |
|                 |
|.    .           |
|E . o . S        |
|.o oo. o         |
|   +=+o          |
|  o+=*.          |
| .=*oo+          |
+-----------------+
</code></pre></li>
<li><p>将170服务器上的公钥发布到150服务器上</p>
<pre><code>[root@m2lan170 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub 192.168.0.150
The authenticity of host &apos;192.168.0.150 (192.168.0.150)&apos; can&apos;t be established.
RSA key fingerprint is e4:e9:2f:ca:75:1d:5a:38:5d:4d:49:66:8a:ca:1a:8c.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &apos;192.168.0.150&apos; (RSA) to the list of known hosts.
root@192.168.0.150&apos;s password: 
Now try logging into the machine, with &quot;ssh &apos;192.168.0.150&apos;&quot;, and check in:

  .ssh/authorized_keys

to make sure we haven&apos;t added extra keys that you weren&apos;t expecting.

[root@m2lan170 ~]# ssh root@192.168.0.150
Last login: Tue Apr 19 20:41:13 2016 from 192.168.1.101
</code></pre></li>
<li><p>现在170服务器登陆150服务器不需要密码，150服务器登陆170服务器需要密码</p>
</li>
<li><p>170服务器给自己发布一个公钥</p>
<pre><code>[root@m2lan170 ~]# ssh-copy-id 192.168.0.170
The authenticity of host &apos;192.168.0.170 (192.168.0.170)&apos; can&apos;t be established.
RSA key fingerprint is f1:37:53:b9:f2:7a:d0:35:4a:ee:f8:82:ed:1c:6a:18.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &apos;192.168.0.170&apos; (RSA) to the list of known hosts.
root@192.168.0.170&apos;s password: 
Now try logging into the machine, with &quot;ssh &apos;192.168.0.170&apos;&quot;, and check in:

  .ssh/authorized_keys

to make sure we haven&apos;t added extra keys that you weren&apos;t expecting.
</code></pre></li>
<li><p>将170服务器的密钥发送给150服务器</p>
<pre><code>[root@m2lan170 ~]# scp /root/.ssh/id_rsa root@192.168.0.150:/root/.ssh/
id_rsa     100% 1675     1.6KB/s   00:00 
</code></pre></li>
<li><p>这时两台服务器互相登陆就不需要输入密码了</p>
</li>
</ul>
<h3 id="通过ssh远程启动服务"><a href="#通过ssh远程启动服务" class="headerlink" title="通过ssh远程启动服务"></a>通过ssh远程启动服务</h3><ul>
<li><p>在150服务器上启动170服务器上的apache</p>
<pre><code>[root@m2lan150 ~]# ssh 192.168.0.170 /etc/init.d/httpd start
正在启动 httpd：[确定]
</code></pre></li>
<li><p>在150服务器查看170服务器的apache状态</p>
<pre><code>[root@m2lan150 ~]# ssh 192.168.0.170 /etc/init.d/httpd status
httpd (pid  6667) 正在运行...
</code></pre></li>
<li><p>在170服务器上启动150服务器上的apache</p>
<pre><code>[root@m2lan170 ~]# ssh 192.168.0.150 /etc/init.d/httpd start
正在启动 httpd：[确定]
</code></pre></li>
<li><p>在170服务器查看150服务器的apache状态</p>
<pre><code>[root@m2lan170 ~]# ssh 192.168.0.150 /etc/init.d/httpd status
httpd (pid  3472) 正在运行...
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下SSHD服务管理&quot;&gt;&lt;a href=&quot;#Linux下SSHD服务管理&quot; class=&quot;headerlink&quot; title=&quot;Linux下SSHD服务管理&quot;&gt;&lt;/a&gt;Linux下SSHD服务管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;sshd服务使用SSH协议进行远程控制，或在计算机之间传输文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;设置sshd端口&quot;&gt;&lt;a href=&quot;#设置sshd端口&quot; class=&quot;headerlink&quot; title=&quot;设置sshd端口&quot;&gt;&lt;/a&gt;设置sshd端口&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将170服务器的sshd端口修改为222&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan170 ~]# cat /etc/ssh/sshd_config | grep Port | grep -v &amp;apos;^#&amp;apos;
Port 222
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;设置sshd访问IP地址&quot;&gt;&lt;a href=&quot;#设置sshd访问IP地址&quot; class=&quot;headerlink&quot; title=&quot;设置sshd访问IP地址&quot;&gt;&lt;/a&gt;设置sshd访问IP地址&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只允许192.168.0.170服务器登陆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# cat /etc/ssh/sshd_config | grep ListenAddress | grep -v &amp;apos;^#&amp;apos;
ListenAddress 192.168.0.170

[root@m2lan150 ~]# /etc/init.d/sshd restart
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;日志存放位置&quot;&gt;&lt;a href=&quot;#日志存放位置&quot; class=&quot;headerlink&quot; title=&quot;日志存放位置&quot;&gt;&lt;/a&gt;日志存放位置&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看日志级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# cat /etc/ssh/sshd_config | grep Syslog | grep -v &amp;apos;^#&amp;apos;
SyslogFacility AUTHPRIV
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看日志存放位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2lan150 ~]# cat /etc/rsyslog.conf | grep ^authpriv
authpriv.*                                              /var/log/secure
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="ssh" scheme="http://blog.golearns.org/tags/ssh/"/>
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>cut</title>
    <link href="http://blog.golearns.org/2017/05/25/cut/"/>
    <id>http://blog.golearns.org/2017/05/25/cut/</id>
    <published>2017-05-25T15:20:06.000Z</published>
    <updated>2017-05-27T17:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下的cut使用"><a href="#Linux下的cut使用" class="headerlink" title="Linux下的cut使用"></a>Linux下的cut使用</h1><blockquote>
<p>cut是一个选取命令，通过将一段数据分析，取出想要的。选取数据一般通过行的方式</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-b</td>
<td>以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非指定了-n标志</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td>以字符为单位进行分割</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td>自定义分隔符，默认为制表符</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td>与-d一起使用，指定显示哪个区域</td>
</tr>
</tbody>
</table>
<h3 id="b参数"><a href="#b参数" class="headerlink" title="-b参数"></a>-b参数</h3><ul>
<li><p>以字节为单位分割</p>
<pre><code># tail显示passwd文件最后5行，cut以字节分割，获取1位置的字节
[root@m2 ~]# tail -n 5 passwd | cut -b 1
s
t
m
z
Z

# tail显示passwd文件最后5行，cut以字节分割，获取1-5位置的字节
[root@m2 ~]# tail -n 5 passwd | cut -b 1-5
sshd:
tcpdu
mysql
zhang
Zhang

# tail显示passwd文件最后5行，cut以字节分割，获取1-5和8-10位置的字节
[root@m2 ~]# tail -n 5 passwd | cut -b 1-5,8-10
sshd:74:
tcpdu:x:
mysql:27
zhangn:x
Zhangn:x
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="c参数"><a href="#c参数" class="headerlink" title="-c参数"></a>-c参数</h3><ul>
<li><p>以字符为单位分割，在中文文件中提取</p>
<pre><code>[root@m2 ~]# cat c.txt 
你好地方司机浪费觉得算了发动机素

[root@m2 ~]# tail -n 5 c.txt | cut -c 1-5
你好地方司
</code></pre></li>
</ul>
<h3 id="d和-f参数结合使用自定义分隔符"><a href="#d和-f参数结合使用自定义分隔符" class="headerlink" title="-d和-f参数结合使用自定义分隔符"></a>-d和-f参数结合使用自定义分隔符</h3><ul>
<li><p>显示passwd文件最后5行，通过自定义分隔符:冒号分割，提取1和3位置的内容</p>
<pre><code>[root@m2 ~]# tail -n 5 passwd | cut -d : -f 1,3
sshd:74
tcpdump:72
mysql:27
zhangsan:500
Zhangsan:500
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下的cut使用&quot;&gt;&lt;a href=&quot;#Linux下的cut使用&quot; class=&quot;headerlink&quot; title=&quot;Linux下的cut使用&quot;&gt;&lt;/a&gt;Linux下的cut使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;cut是一个选取命令，通过将一段数据分析，取出想要的。选取数据一般通过行的方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-b&lt;/td&gt;
&lt;td&gt;以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非指定了-n标志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-c&lt;/td&gt;
&lt;td&gt;以字符为单位进行分割&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-d&lt;/td&gt;
&lt;td&gt;自定义分隔符，默认为制表符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-f&lt;/td&gt;
&lt;td&gt;与-d一起使用，指定显示哪个区域&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;b参数&quot;&gt;&lt;a href=&quot;#b参数&quot; class=&quot;headerlink&quot; title=&quot;-b参数&quot;&gt;&lt;/a&gt;-b参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;以字节为单位分割&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# tail显示passwd文件最后5行，cut以字节分割，获取1位置的字节
[root@m2 ~]# tail -n 5 passwd | cut -b 1
s
t
m
z
Z

# tail显示passwd文件最后5行，cut以字节分割，获取1-5位置的字节
[root@m2 ~]# tail -n 5 passwd | cut -b 1-5
sshd:
tcpdu
mysql
zhang
Zhang

# tail显示passwd文件最后5行，cut以字节分割，获取1-5和8-10位置的字节
[root@m2 ~]# tail -n 5 passwd | cut -b 1-5,8-10
sshd:74:
tcpdu:x:
mysql:27
zhangn:x
Zhangn:x
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>awk</title>
    <link href="http://blog.golearns.org/2017/05/25/awk/"/>
    <id>http://blog.golearns.org/2017/05/25/awk/</id>
    <published>2017-05-25T15:19:04.000Z</published>
    <updated>2017-05-27T17:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下的awk使用"><a href="#Linux下的awk使用" class="headerlink" title="Linux下的awk使用"></a>Linux下的awk使用</h1><blockquote>
<p>awk分析文件数据，根据分隔符对一行一行的数据进行拆分，获取某一列
分隔符默认是空格，可以使用-F;以分号为分隔符,-F:以冒号为分隔符</p>
</blockquote>
<ul>
<li><p>获取当前主机指定网卡的IP地址</p>
<pre><code>[root@m2 ~]# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:0C:29:C6:3D:D5  
inet addr:192.168.0.150  Bcast:192.168.0.255  Mask:255.255.255.0
inet6 addr: fe80::20c:29ff:fec6:3dd5/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:11240 errors:0 dropped:0 overruns:0 frame:0
TX packets:2747 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000 
RX bytes:1389465 (1.3 MiB)  TX bytes:207415 (202.5 KiB)

[root@m2 ~]# ifconfig eth0 | grep &quot;inet addr:&quot; | awk &apos;{print $2}&apos; | awk -F : &apos;{print $2}&apos;
192.168.0.150
</code></pre></li>
<li><p>获取/etc/passwd中用户UID大于500的用户名和用户登陆的shell</p>
<pre><code>[root@m2 ~]# cat passwd | awk -F  : &apos;$3&gt;500{print $1,$7}&apos;
nfsnobody /sbin/nologin

# 使用\t制表符隔开
[root@m2 ~]# cat passwd | awk -F : &apos;$3&gt;500{print $1 &quot;\t&quot; $7}&apos;
nfsnobody    /sbin/nologin
</code></pre></li>
</ul>
<a id="more"></a>
<ul>
<li><p>获取/etc/passwd中用户UID&gt;=500并且登陆shell为/bin/bash的用户名和登陆shell</p>
<pre><code>[root@m2 ~]# cat passwd | awk -F : &apos;$3&gt;=500 &amp;&amp; $7==&quot;/bin/bash&quot;{print $1,$7}&apos;
zhangsan /bin/bash
Zhangsan /bin/bash

# 显示行号
[root@m2 ~]# nl passwd | awk -F : &apos;$3&gt;=500 &amp;&amp; $7==&quot;/bin/bash&quot;{print $1,$7}&apos;
35    zhangsan /bin/bash
36    Zhangsan /bin/bash
</code></pre></li>
<li><p>使用BEGIN和END，在筛选前和筛选后分别输出一些内容</p>
<pre><code>[root@m2 ~]# cat passwd | awk -F : &apos;BEGIN {print &quot;用户名 \t 使用的shell&quot;} $3&gt;500 {print $1 &quot;\t&quot; $7} END {print &quot;end&quot;}&apos;
用户名      使用的shell
nfsnobody    /sbin/nologin
end
</code></pre></li>
<li><p>获取指定目录下所有文件总大小,定义size变量用来统计</p>
<pre><code>[root@m2 ~]# ls -l /etc/ | awk &apos;BEGIN {size=0;} {size+=$5;} END {print &quot;总大小：&quot;,size/1024/1024,&quot;Mb&quot;}&apos;
总大小： 1.84909 Mb
</code></pre></li>
<li><p>统计当前电脑内存使用百分比</p>
<pre><code>[root@m2 sh]# vim example19.sh
#!/bin/bash
echo &apos;显示内存使用百分比：&apos;
use=`free -m | grep &apos;cache:&apos; | awk &apos;{print $3}&apos;`
total=`free -m | grep &apos;Mem:&apos; | awk &apos;{print $2}&apos;`
result=`expr $use \* 100 / $total`
echo &quot;使用百分比为：$result%&quot;

[root@m2 sh]# chmod +x example19.sh
[root@m2 sh]# ./example19.sh 
显示内存使用百分比：
使用百分比为：20%
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下的awk使用&quot;&gt;&lt;a href=&quot;#Linux下的awk使用&quot; class=&quot;headerlink&quot; title=&quot;Linux下的awk使用&quot;&gt;&lt;/a&gt;Linux下的awk使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;awk分析文件数据，根据分隔符对一行一行的数据进行拆分，获取某一列
分隔符默认是空格，可以使用-F;以分号为分隔符,-F:以冒号为分隔符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取当前主机指定网卡的IP地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2 ~]# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:0C:29:C6:3D:D5  
inet addr:192.168.0.150  Bcast:192.168.0.255  Mask:255.255.255.0
inet6 addr: fe80::20c:29ff:fec6:3dd5/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:11240 errors:0 dropped:0 overruns:0 frame:0
TX packets:2747 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000 
RX bytes:1389465 (1.3 MiB)  TX bytes:207415 (202.5 KiB)

[root@m2 ~]# ifconfig eth0 | grep &amp;quot;inet addr:&amp;quot; | awk &amp;apos;{print $2}&amp;apos; | awk -F : &amp;apos;{print $2}&amp;apos;
192.168.0.150
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取/etc/passwd中用户UID大于500的用户名和用户登陆的shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@m2 ~]# cat passwd | awk -F  : &amp;apos;$3&amp;gt;500{print $1,$7}&amp;apos;
nfsnobody /sbin/nologin

# 使用\t制表符隔开
[root@m2 ~]# cat passwd | awk -F : &amp;apos;$3&amp;gt;500{print $1 &amp;quot;\t&amp;quot; $7}&amp;apos;
nfsnobody    /sbin/nologin
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>sed</title>
    <link href="http://blog.golearns.org/2017/05/25/sed/"/>
    <id>http://blog.golearns.org/2017/05/25/sed/</id>
    <published>2017-05-25T15:15:24.000Z</published>
    <updated>2017-05-27T17:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下的sed使用"><a href="#Linux下的sed使用" class="headerlink" title="Linux下的sed使用"></a>Linux下的sed使用</h1><blockquote>
<p>流编辑器，sed编辑器是一行一行处理文件内容。正在处理的内容放入缓冲区内
处理完成后根据选项进行输出或文件修改</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-n</td>
<td>抑制自动(默认)输出，读取下一个输入行</td>
</tr>
<tr>
<td style="text-align:center">-i</td>
<td>编辑文件内容</td>
</tr>
<tr>
<td style="text-align:center">-e</td>
<td>执行多次</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td>在匹配后追加</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td>在匹配后插入</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td>打印</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td>删除</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td>另存</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td>替换</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td>查找</td>
</tr>
<tr>
<td style="text-align:center">h/H</td>
<td>复制copy</td>
</tr>
<tr>
<td style="text-align:center">g/G</td>
<td>粘贴</td>
</tr>
</tbody>
</table>
<h3 id="s命令"><a href="#s命令" class="headerlink" title="s命令"></a>s命令</h3><ul>
<li><p>查找替换</p>
<pre><code># 将root替换为boot
[root@m2 ~]# sed &apos;s/root/boot/&apos; passwd | grep boot --color
boot:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/boot:/sbin/nologin

# 将所有root替换为boot,g表示替换所有
[root@m2 ~]# sed &apos;s/root/boot/g&apos; passwd | grep boot --color
boot:x:0:0:boot:/boot:/bin/bash
operator:x:11:0:operator:/boot:/sbin/nologin

# 给查找的目标内容添加括号,&amp;表示查找的内容
[root@m2 ~]# sed &apos;s/root/(&amp;)/&apos; passwd | grep &apos;(root)&apos; --color
(root):x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/(root):/sbin/nologin

# 给所有行添加注释
[root@m2 ~]# sed &apos;s/^[a-zA-Z]/#&amp;/&apos; passwd 
#root:x:0:0:root:/root:/bin/bash
#bin:x:1:1:bin:/bin:/sbin/nologin

# 多次替换,-e
[root@m2 ~]# sed -e &apos;s/root/boot/&apos; -e &apos;s/message/messages/&apos; passwd | grep &quot;\&lt;boot\|messages\&gt;&quot; --color
boot:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/boot:/sbin/nologin
dbus:x:81:81:System messages bus:/:/sbin/nologin

# 替换指定行
[root@m2 ~]# sed &apos;1,5s/root/boot/&apos; passwd | grep boot --color -n
1:boot:x:0:0:root:/root:/bin/bash
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="n-p命令"><a href="#n-p命令" class="headerlink" title="n,p命令"></a>n,p命令</h3><ul>
<li><p>显示指定行</p>
<pre><code># 显示第5行
[root@m2 ~]# sed -n &apos;5p&apos; passwd 
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

# 显示前五行的内容
[root@m2 ~]# sed -n &apos;1,5p&apos; passwd 
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

# 显示除前五行之外的其他行,使用!号
[root@m2 ~]# sed -n &apos;1,5!p&apos; passwd 
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin

# 显示第五行和第五行之后的三行
[root@m2 ~]# sed -n &apos;5,+3p&apos; passwd 
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt

# 显示文件总行数
[root@m2 ~]# sed -n &apos;$=&apos; passwd 
36
</code></pre></li>
</ul>
<h3 id="i-a命令"><a href="#i-a命令" class="headerlink" title="i,a命令"></a>i,a命令</h3><ul>
<li><p>在行前和行尾插入</p>
<pre><code># 在第一行前面插入一行
[root@m2 ~]# sed &apos;1ihello world one line&apos; passwd 
hello world one line
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin

# 在最后一行后面插入一行
[root@m2 ~]# sed &apos;$a插入最后一行&apos; passwd
Zhangsan:x:500:500::/home/zhangsan:/bin/bash
插入最后一行

# 在第一行后面插入多行,使用反斜杠(\)进行断行操作
[root@m2 ~]# sed &apos;1ahello \
&gt; world&apos; passwd
root:x:0:0:root:/root:/bin/bash
hello 
world
bin:x:1:1:bin:/bin:/sbin/nologin
</code></pre></li>
</ul>
<h3 id="c命令"><a href="#c命令" class="headerlink" title="c命令"></a>c命令</h3><ul>
<li><p>内容替换</p>
<pre><code># 将第二行内容全部替换为Hello world
[root@m2 ~]# sed &apos;2cHello world&apos; passwd 
root:x:0:0:root:/root:/bin/bash
Hello world
daemon:x:2:2:daemon:/sbin:/sbin/nologin
</code></pre></li>
</ul>
<h3 id="nl命令"><a href="#nl命令" class="headerlink" title="nl命令"></a>nl命令</h3><ul>
<li><p>显示文件行号</p>
<pre><code># 显示第三行-第五行内容，并显示行号
[root@m2 ~]# nl passwd | sed -n &apos;3,5p&apos;
 3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
 4    adm:x:3:4:adm:/var/adm:/sbin/nologin
 5    lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

# 在第二行后插入多行，并显示行号
[root@m2 ~]# nl passwd | sed &apos;2a hahhaha \
&gt; hehehehhe &apos;
     1    root:x:0:0:root:/root:/bin/bash
     2    bin:x:1:1:bin:/bin:/sbin/nologin
hahhaha 
hehehehhe 
     3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
     4    adm:x:3:4:adm:/var/adm:/sbin/nologin

# 直接显示文件内容和行号
[root@m2 ~]# nl passwd 
 1    root:x:0:0:root:/root:/bin/bash
 2    bin:x:1:1:bin:/bin:/sbin/nologin
 3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
 4    adm:x:3:4:adm:/var/adm:/sbin/nologin
</code></pre></li>
</ul>
<h3 id="i命令"><a href="#i命令" class="headerlink" title="-i命令"></a>-i命令</h3><ul>
<li><p>将修改的内容写入文件</p>
<pre><code># 将修改的内容写入文件
[root@m2 ~]# sed -i &apos;s/messagess/message/&apos; passwd
</code></pre></li>
</ul>
<h3 id="H-G命令"><a href="#H-G命令" class="headerlink" title="H,G命令"></a>H,G命令</h3><ul>
<li><p>复制粘贴</p>
<pre><code># 将1-4行的内容复制到第四行后面
[root@m2 ~]# nl passwd | sed &apos;1,4H;4G&apos;
 1    root:x:0:0:root:/root:/bin/bash
 2    bin:x:1:1:bin:/bin:/sbin/nologin
 3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
 4    adm:x:3:4:adm:/var/adm:/sbin/nologin

 1    root:x:0:0:root:/root:/bin/bash
 2    bin:x:1:1:bin:/bin:/sbin/nologin
 3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
 4    adm:x:3:4:adm:/var/adm:/sbin/nologin
 5    lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
</code></pre></li>
</ul>
<h3 id="d命令"><a href="#d命令" class="headerlink" title="d命令"></a>d命令</h3><ul>
<li><p>删除</p>
<pre><code># 将开头内容为Zhangsan的行删除
[root@m2 ~]# sed &apos;/^Zhangsan/d&apos; passwd &gt; newpasswd
[root@m2 ~]# vim newpasswd
</code></pre></li>
</ul>
<h3 id="w命令"><a href="#w命令" class="headerlink" title="w命令"></a>w命令</h3><ul>
<li><p>写入,过滤</p>
<pre><code># 过滤含有root内容的行，写入到新文件newpasswd中
# 可以用来过滤文件内容，并写入到新文件
[root@m2 ~]# sed &apos;/root/w newpasswd&apos; passwd
[root@m2 ~]# cat newpasswd 
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux下的sed使用&quot;&gt;&lt;a href=&quot;#Linux下的sed使用&quot; class=&quot;headerlink&quot; title=&quot;Linux下的sed使用&quot;&gt;&lt;/a&gt;Linux下的sed使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;流编辑器，sed编辑器是一行一行处理文件内容。正在处理的内容放入缓冲区内
处理完成后根据选项进行输出或文件修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-n&lt;/td&gt;
&lt;td&gt;抑制自动(默认)输出，读取下一个输入行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-i&lt;/td&gt;
&lt;td&gt;编辑文件内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-e&lt;/td&gt;
&lt;td&gt;执行多次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;a&lt;/td&gt;
&lt;td&gt;在匹配后追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;i&lt;/td&gt;
&lt;td&gt;在匹配后插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;p&lt;/td&gt;
&lt;td&gt;打印&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;d&lt;/td&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;w&lt;/td&gt;
&lt;td&gt;另存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;c&lt;/td&gt;
&lt;td&gt;替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;s&lt;/td&gt;
&lt;td&gt;查找&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;h/H&lt;/td&gt;
&lt;td&gt;复制copy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;g/G&lt;/td&gt;
&lt;td&gt;粘贴&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;s命令&quot;&gt;&lt;a href=&quot;#s命令&quot; class=&quot;headerlink&quot; title=&quot;s命令&quot;&gt;&lt;/a&gt;s命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查找替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 将root替换为boot
[root@m2 ~]# sed &amp;apos;s/root/boot/&amp;apos; passwd | grep boot --color
boot:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/boot:/sbin/nologin

# 将所有root替换为boot,g表示替换所有
[root@m2 ~]# sed &amp;apos;s/root/boot/g&amp;apos; passwd | grep boot --color
boot:x:0:0:boot:/boot:/bin/bash
operator:x:11:0:operator:/boot:/sbin/nologin

# 给查找的目标内容添加括号,&amp;amp;表示查找的内容
[root@m2 ~]# sed &amp;apos;s/root/(&amp;amp;)/&amp;apos; passwd | grep &amp;apos;(root)&amp;apos; --color
(root):x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/(root):/sbin/nologin

# 给所有行添加注释
[root@m2 ~]# sed &amp;apos;s/^[a-zA-Z]/#&amp;amp;/&amp;apos; passwd 
#root:x:0:0:root:/root:/bin/bash
#bin:x:1:1:bin:/bin:/sbin/nologin

# 多次替换,-e
[root@m2 ~]# sed -e &amp;apos;s/root/boot/&amp;apos; -e &amp;apos;s/message/messages/&amp;apos; passwd | grep &amp;quot;\&amp;lt;boot\|messages\&amp;gt;&amp;quot; --color
boot:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/boot:/sbin/nologin
dbus:x:81:81:System messages bus:/:/sbin/nologin

# 替换指定行
[root@m2 ~]# sed &amp;apos;1,5s/root/boot/&amp;apos; passwd | grep boot --color -n
1:boot:x:0:0:root:/root:/bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.golearns.org/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.golearns.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Exchanger</title>
    <link href="http://blog.golearns.org/2017/05/21/Exchanger/"/>
    <id>http://blog.golearns.org/2017/05/21/Exchanger/</id>
    <published>2017-05-21T08:44:47.000Z</published>
    <updated>2017-05-21T08:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发编程类Exchanger"><a href="#Java并发编程类Exchanger" class="headerlink" title="Java并发编程类Exchanger"></a>Java并发编程类Exchanger</h1><pre><code>/**
 * Exchanger用于两个线程之间的数据交换
 * 线程会阻塞在Exchanger的exchange方法上
 * 直到另外一个线程也到达同一个Exchanger的exchange方法上
 * 二者进行交换
 * 无论谁先到达Exchanger的exchange方法，都会等待另外一个线程也到达，然后交换数据
 */
public class ExchangerDemo1 {

    public static void main(String[] args) {
        final Exchanger&lt;List&lt;Integer&gt;&gt; exchanger = new Exchanger&lt;&gt;();

        Runnable runnable1 = () -&gt; {
            List&lt;Integer&gt; lists = new ArrayList&lt;&gt;();
            lists.add(1);
            lists.add(2);

            try {
                lists = exchanger.exchange(lists);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(&quot;aa[1, 2] &quot; + lists);
        };

        Runnable runnable2 = () -&gt; {
            List&lt;Integer&gt; lists = new ArrayList&lt;&gt;();
            lists.add(3);
            lists.add(4);

            try {
                lists = exchanger.exchange(lists);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(&quot;bb[3, 4] &quot; + lists);
        };

        ExecutorService service = Executors.newFixedThreadPool(3);
        service.execute(runnable1);
        service.execute(runnable2);
        service.shutdown();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java并发编程类Exchanger&quot;&gt;&lt;a href=&quot;#Java并发编程类Exchanger&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程类Exchanger&quot;&gt;&lt;/a&gt;Java并发编程类Exchanger&lt;/h1&gt;&lt;pre&gt;&lt;cod
    
    </summary>
    
      <category term="并发" scheme="http://blog.golearns.org/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://blog.golearns.org/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore</title>
    <link href="http://blog.golearns.org/2017/05/21/Semaphore/"/>
    <id>http://blog.golearns.org/2017/05/21/Semaphore/</id>
    <published>2017-05-21T08:03:20.000Z</published>
    <updated>2017-05-21T08:56:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发编程类Semaphore"><a href="#Java并发编程类Semaphore" class="headerlink" title="Java并发编程类Semaphore"></a>Java并发编程类Semaphore</h1><pre><code>/**
 * 限制可以访问资源的线程数
 */
public class SemaphoreDemo1 {

    public static void main(String[] args) {
        final Semaphore semaphore = new Semaphore(3);

        Runnable runnable = () -&gt; {
            System.out.println(Thread.currentThread().getName() + &quot; 可用的Semaphore permits: &quot; + semaphore.availablePermits());
            try {

                // 获取Semaphore permits
                semaphore.acquire();

                try {
                    for (int i = 0; i &lt; 5; i++) {
                        System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i + &quot; : 可用的Semaphore permits: &quot; + semaphore.availablePermits());
                        Thread.sleep(1000);
                    }
                } finally {
                    System.out.println(Thread.currentThread().getName() + &quot;释放锁&quot;);
                    // 释放锁
                    semaphore.release();
                    System.out.println(Thread.currentThread().getName() + &quot;可用的Semaphore permits: &quot; + semaphore.availablePermits());
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };

        ExecutorService service = Executors.newFixedThreadPool(3);
        for (int i = 0; i &lt; 5; i++) {
            service.execute(runnable);
        }
        service.shutdown();
    }
}

/**
 * 限制可以访问资源的线程数，一次只有一个线程可以访问资源
 */
public class SemaphoreDemo1 {

    public static void main(String[] args) {
        // 互斥锁，Semaphore为1
        final Semaphore semaphore = new Semaphore(1);

        Runnable runnable = () -&gt; {
            System.out.println(Thread.currentThread().getName() + &quot; 可用的Semaphore permits: &quot; + semaphore.availablePermits());
            try {

                // 获取Semaphore permits
                semaphore.acquire();

                try {
                    for (int i = 0; i &lt; 5; i++) {
                        System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i + &quot; : 可用的Semaphore permits: &quot; + semaphore.availablePermits());
                        Thread.sleep(1000);
                    }
                } finally {
                    System.out.println(Thread.currentThread().getName() + &quot;释放锁&quot;);
                    // 释放锁
                    semaphore.release();
                    System.out.println(Thread.currentThread().getName() + &quot;可用的Semaphore permits: &quot; + semaphore.availablePermits());
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };

        ExecutorService service = Executors.newFixedThreadPool(3);
        for (int i = 0; i &lt; 5; i++) {
            service.execute(runnable);
        }
        service.shutdown();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java并发编程类Semaphore&quot;&gt;&lt;a href=&quot;#Java并发编程类Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程类Semaphore&quot;&gt;&lt;/a&gt;Java并发编程类Semaphore&lt;/h1&gt;&lt;pre&gt;&lt;cod
    
    </summary>
    
      <category term="并发" scheme="http://blog.golearns.org/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://blog.golearns.org/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier</title>
    <link href="http://blog.golearns.org/2017/05/21/CyclicBarrier/"/>
    <id>http://blog.golearns.org/2017/05/21/CyclicBarrier/</id>
    <published>2017-05-21T07:53:54.000Z</published>
    <updated>2017-05-21T08:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发编程类CyclicBarrier"><a href="#Java并发编程类CyclicBarrier" class="headerlink" title="Java并发编程类CyclicBarrier"></a>Java并发编程类CyclicBarrier</h1><pre><code>/**
 * CyclicBarrier协同多个线程
 * 用于同步所有调用await方法的线程，并且等所有线程都到了await方法时
 * 这些线程才一起返回继续各自的工作
 */
public class CyclicBarrierDemo1 {

    public static void main(String[] args) {
        int count = 10;
        final CyclicBarrier barrier = new CyclicBarrier(count + 1);
        Runnable rannable = () -&gt; {
            System.out.println(Thread.currentThread().getName() + &quot; : hahhahaha&quot;);
            try {
                barrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        };

        ExecutorService service = Executors.newFixedThreadPool(count);
        for (int i = 0; i &lt; count; i++) {
            service.execute(rannable);
        }

        try {
            barrier.await();
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }

        service.shutdown();
        System.out.println(&quot;执行完毕&quot;);
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java并发编程类CyclicBarrier&quot;&gt;&lt;a href=&quot;#Java并发编程类CyclicBarrier&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程类CyclicBarrier&quot;&gt;&lt;/a&gt;Java并发编程类CyclicBarri
    
    </summary>
    
      <category term="并发" scheme="http://blog.golearns.org/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://blog.golearns.org/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Atomics</title>
    <link href="http://blog.golearns.org/2017/05/21/Atomics/"/>
    <id>http://blog.golearns.org/2017/05/21/Atomics/</id>
    <published>2017-05-21T07:39:22.000Z</published>
    <updated>2017-05-21T08:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发编程类Atomics"><a href="#Java并发编程类Atomics" class="headerlink" title="Java并发编程类Atomics"></a>Java并发编程类Atomics</h1><pre><code>// 使用synchronized
public class Counter1 {

    private int counter = 0;
    public int increase() {
        synchronized (this) {
            counter += 1;
            return counter;
        }
    }

    public int decrease() {
        synchronized (this) {
            counter -= 1;
            return counter;
        }
    }

    public static void main(String[] args) {
        Counter1 c1 = new Counter1();
        ExecutorService service = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 100; i++) {
            service.execute(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + c1.increase());
            });
        }
        service.shutdown();
    }
}

// 使用AtomicInteger
public class Counter2 {

    private AtomicInteger counter = new AtomicInteger(0);

    public int increase() {
        return counter.incrementAndGet();
    }

    public int descrease() {
        return counter.decrementAndGet();
    }

    public static void main(String[] args) {
        Counter2 c2 = new Counter2();
        ExecutorService service = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 100; i++) {
            service.execute(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + c2.increase());
            });
        }
        service.shutdown();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java并发编程类Atomics&quot;&gt;&lt;a href=&quot;#Java并发编程类Atomics&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程类Atomics&quot;&gt;&lt;/a&gt;Java并发编程类Atomics&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;// 使用s
    
    </summary>
    
      <category term="并发" scheme="http://blog.golearns.org/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://blog.golearns.org/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://blog.golearns.org/2017/05/21/ReentrantLock/"/>
    <id>http://blog.golearns.org/2017/05/21/ReentrantLock/</id>
    <published>2017-05-21T07:35:56.000Z</published>
    <updated>2017-05-21T08:56:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发编程类ReentrantLock"><a href="#Java并发编程类ReentrantLock" class="headerlink" title="Java并发编程类ReentrantLock"></a>Java并发编程类ReentrantLock</h1><pre><code>public class ReentrantLockDemo1 {

    private final ReentrantLock lock = new ReentrantLock();
    private final Map&lt;String, String&gt; maps = new HashMap&lt;&gt;();

    public void add(String key, String value) {
        final ReentrantLock lock = this.lock;
        lock.lock();

        try {
            if (null == maps.get(key)) {
                maps.put(key, value);
            }
        } finally {
            lock.unlock();
        }
    }

    public void remove(String key) {
        final ReentrantLock lock = this.lock;
        lock.lock();

        try {
            if (null != maps.get(key)) {
                maps.remove(key);
            }
        } finally {
            lock.unlock();
        }
    }

    public void getMaps() {
        maps.forEach((k, v) -&gt; {
            System.out.println(&quot;key: &quot; + k + &quot;, value: &quot; + v);
        });
    }

    public static void main(String[] args) throws Exception {
        ReentrantLockDemo1 r1 = new ReentrantLockDemo1();
        ExecutorService service = Executors.newFixedThreadPool(5);
        final List&lt;Future&lt;?&gt;&gt; lists = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 20; i++) {
            final Integer[] is = new Integer[1];
            is[0] = i;
            Future&lt;?&gt; submit = service.submit(() -&gt; {
                r1.add(&quot;key &quot; + is[0], &quot;value &quot; + is[0]);
            });
            lists.add(submit);
        }
        service.shutdown();

        for (Future&lt;?&gt; future : lists) {
            while (!future.isDone()) {}

            future.get();
        }

        r1.getMaps();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java并发编程类ReentrantLock&quot;&gt;&lt;a href=&quot;#Java并发编程类ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程类ReentrantLock&quot;&gt;&lt;/a&gt;Java并发编程类ReentrantLo
    
    </summary>
    
      <category term="并发" scheme="http://blog.golearns.org/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://blog.golearns.org/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch</title>
    <link href="http://blog.golearns.org/2017/05/21/CountDownLatch/"/>
    <id>http://blog.golearns.org/2017/05/21/CountDownLatch/</id>
    <published>2017-05-21T07:32:28.000Z</published>
    <updated>2017-05-21T08:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发编程类CountDownLatch"><a href="#Java并发编程类CountDownLatch" class="headerlink" title="Java并发编程类CountDownLatch"></a>Java并发编程类CountDownLatch</h1><pre><code>public class CountDownLatchDemo1 {

    public static void main(String[] args) {
        int count = 10;
        final CountDownLatch downLatch = new CountDownLatch(count);
        Runnable rannable = () -&gt; {
            System.out.println(Thread.currentThread().getName() + &quot; : hahhahaha&quot;);
            downLatch.countDown();
        };

        ExecutorService service = Executors.newFixedThreadPool(2);
        for (int i = 0; i &lt; count; i++) {
            service.execute(rannable);
        }
        service.shutdown();

        // 当多个线程都达到了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件来触发后续的工作
        try {
            downLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 当上面当所有线程都完成了downLatch.countDown调用后，会从downLatch.await返回后执行以下操作
        System.out.println(&quot;执行完毕&quot;);
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java并发编程类CountDownLatch&quot;&gt;&lt;a href=&quot;#Java并发编程类CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程类CountDownLatch&quot;&gt;&lt;/a&gt;Java并发编程类CountDow
    
    </summary>
    
      <category term="并发" scheme="http://blog.golearns.org/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://blog.golearns.org/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>大型网站核心架构要素</title>
    <link href="http://blog.golearns.org/2017/05/11/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%A6%81%E7%B4%A0/"/>
    <id>http://blog.golearns.org/2017/05/11/大型网站核心架构要素/</id>
    <published>2017-05-11T15:15:54.000Z</published>
    <updated>2017-05-11T15:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大型网站核心架构要素"><a href="#大型网站核心架构要素" class="headerlink" title="大型网站核心架构要素"></a>大型网站核心架构要素</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>从用户浏览器到数据库，影响用户请求的所有环节都可以进行性能优化</li>
<li>在浏览器端，可以通过浏览器缓存、使用页面压缩、合理布局页面、减少cookie传输等手段改善性能</li>
<li>还可以使用CDN，将网站静态内容分发至离用户最近的网络服务商机房，使用户通过最短访问路径获取数据。可以在网站机房部署反向代理服务器，缓存热点文件，加快请求响应速度，减轻应用服务器负载压力</li>
<li>在应用服务器端，可以使用服务器本地缓存和分布式缓存，通过缓存在内存中的热点数据处理用户请求，加快请求处理过程，减轻数据库负载压力</li>
<li>也可以通过异步操作将用户请求发送至消息队列等待后续任务处理，而当前请求直接返回响应给用户</li>
<li>在网站有很多用户高并发请求的情况下，可以将多台应用服务器组成一个集群共同对外服务，提高整体处理能力，改善性能</li>
<li>在代码层面，也可以通过使用多线程、改善内存管理等手段优化性能</li>
<li>在数据库服务器端，索引、缓存、SQL优化等性能优化手段都已经比较成熟。而NoSQL数据库通过优化数据模型、存储结构、伸缩特性等手段在性能方面的优势也日趋明显</li>
<li>衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等，通过测试这些指标以确定系统设计是否达到目标。这些指标也是网站监控的重要参数，通过监控这些指标可以分析系统瓶颈，预测网站容量，并对异常指标进行报警，保障系统可用性</li>
</ul>
<a id="more"></a>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><ul>
<li>网站高可用的主要手段是冗余，应用部署在多台服务器上同时提供访问，数据存储在多台服务器上互相备份，任何一台服务器宕机都不会影响应用的整体可用，也不会导致数据丢失</li>
<li>对于应用服务器而言，多台应用服务器通过负载均衡设备组成一个集群共同对外提供服务，任何一台服务器宕机，只需把请求切换到其它服务器就可实现应用到高可用，但是一个前提条件是应用服务器上不能保存请求的会话信息。否则服务器宕机，会话丢失，即使将用户请求转发到其它服务器上也无法完成业务处理</li>
<li>对于存储服务器，由于存储着数据，需要对数据进行实时备份，当服务器宕机时需要将数据访问转移到可用的服务器上，并进行数据恢复以保证继续游服务器宕机的时候数据依然可用</li>
<li>除了运行环境，网站的高可用还需要软件开发过程的质量保证。通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境等可能，避免故障范围扩大</li>
<li>衡量一个系统架构设计是否满足高可用的目标，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种不可预期的问题时，系统整体是否依然可用</li>
</ul>
<h2 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h2><ul>
<li>衡量架构伸缩性的主要标准就是是否可以用多台服务器构建集群，是否容易向集群中添加新的服务器。加入新的服务器后是否可以提供和原来服务器无差别的服务。集群中可容纳的总的服务器数量是否有限制</li>
<li>对于应用服务器集群，只要服务器上不保存数据，所有服务器都是对等的，通过使用合适的负载均衡设备就可以向集群中不断加入服务器</li>
<li>对于缓存服务器集群，加入新的服务器可能会导致缓存路由失效，进而导致集群中大部分缓存都无法访问。虽然缓存的数据可以通过数据库重新加载，但是如果应用已经严重依赖缓存，可能会导致整个网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性</li>
<li>关系数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群</li>
<li>至于大部分NoSQL数据库产品，由于其先天就是为海量数据而生，因此其对伸缩性的支持通常都非常好，可以做到在较少运维参与的情况下实现集群规模的线性伸缩</li>
</ul>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><ul>
<li>网站可扩展架构的主要手段是事件驱动架构和分布式服务</li>
<li>事件驱动架构在网站通常利用消息队列实现，将用户请求和其它业务事件构造成消息发布到消息队列，消息的处理者作为消息者从消息队列中获取消息进行处理。通过这种方式将消息产生和消息处理分离开来，可以透明地增加新的消息生产者任务或者心的消息消费者任务</li>
<li>分布式服务是将业务和可复用服务分离开来，通过分布式服务框架调用。新增产品可以通过调用可复用的服务实现自身的业务逻辑，而对现有产品没有任何影响。可复用服务升级变更的时候，也可以通过提供多版本服务对应用实现透明升级，不需要强制应用同步变更。</li>
</ul>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul>
<li>网站的安全架构就是保护网站不受恶意访问和攻击，保护网站的重要数据不被窃取</li>
<li>衡量网站安全架构的标准就是针对现存和潜在的各种攻击与窃密手段，是否有可靠的应对策略</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;大型网站核心架构要素&quot;&gt;&lt;a href=&quot;#大型网站核心架构要素&quot; class=&quot;headerlink&quot; title=&quot;大型网站核心架构要素&quot;&gt;&lt;/a&gt;大型网站核心架构要素&lt;/h1&gt;&lt;h2 id=&quot;性能&quot;&gt;&lt;a href=&quot;#性能&quot; class=&quot;headerlink&quot; title=&quot;性能&quot;&gt;&lt;/a&gt;性能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;从用户浏览器到数据库，影响用户请求的所有环节都可以进行性能优化&lt;/li&gt;
&lt;li&gt;在浏览器端，可以通过浏览器缓存、使用页面压缩、合理布局页面、减少cookie传输等手段改善性能&lt;/li&gt;
&lt;li&gt;还可以使用CDN，将网站静态内容分发至离用户最近的网络服务商机房，使用户通过最短访问路径获取数据。可以在网站机房部署反向代理服务器，缓存热点文件，加快请求响应速度，减轻应用服务器负载压力&lt;/li&gt;
&lt;li&gt;在应用服务器端，可以使用服务器本地缓存和分布式缓存，通过缓存在内存中的热点数据处理用户请求，加快请求处理过程，减轻数据库负载压力&lt;/li&gt;
&lt;li&gt;也可以通过异步操作将用户请求发送至消息队列等待后续任务处理，而当前请求直接返回响应给用户&lt;/li&gt;
&lt;li&gt;在网站有很多用户高并发请求的情况下，可以将多台应用服务器组成一个集群共同对外服务，提高整体处理能力，改善性能&lt;/li&gt;
&lt;li&gt;在代码层面，也可以通过使用多线程、改善内存管理等手段优化性能&lt;/li&gt;
&lt;li&gt;在数据库服务器端，索引、缓存、SQL优化等性能优化手段都已经比较成熟。而NoSQL数据库通过优化数据模型、存储结构、伸缩特性等手段在性能方面的优势也日趋明显&lt;/li&gt;
&lt;li&gt;衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等，通过测试这些指标以确定系统设计是否达到目标。这些指标也是网站监控的重要参数，通过监控这些指标可以分析系统瓶颈，预测网站容量，并对异常指标进行报警，保障系统可用性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="架构" scheme="http://blog.golearns.org/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://blog.golearns.org/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构模式</title>
    <link href="http://blog.golearns.org/2017/05/11/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.golearns.org/2017/05/11/大型网站架构模式/</id>
    <published>2017-05-11T14:18:57.000Z</published>
    <updated>2017-05-11T15:47:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><ul>
<li>分层是：将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统</li>
<li>在大型网站分层架构中，将网站软件系统分为应用层、服务层和数据层</li>
</ul>
<table>
<thead>
<tr>
<th>#</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td style="text-align:center">负责具体业务和试图展示，如网站首页及搜索输入和结果展示</td>
</tr>
<tr>
<td>服务层</td>
<td style="text-align:center">为应用层提供服务支持，如用户管理服务，购物车服务等</td>
</tr>
<tr>
<td>数据层</td>
<td style="text-align:center">提供数据存储访问服务，如数据库、缓存、文件、搜索引擎等</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><ul>
<li>分割是：在纵向方面对软件进行切分</li>
<li>网站越大，功能越复杂，服务和数据处理的种类也越多，将这些不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，一方面有助于软件的开发和维护，另一方面便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul>
<li>对于大型网站，分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同的服务器上，通过远程调用协同工作。分布式意味着可以使用更多的计算机完成相同的功能，计算机越多，CPU、内存、存储资源也就越多，能够处理的并发访问和数据量就越大，进而能够为更多的用户提供服务</li>
<li>常用的分布式：<ul>
<li><strong>分布式应用和服务</strong>：将分层和分割后的应用和服务模块分布式部署，除了可以改善网站性能和开发性、加快开发和发布速度、减少数据库连接资源消耗快，还可以使不同应用复用共同的服务，便于业务功能扩展</li>
<li><strong>分布式静态资源</strong>：网站的静态资源如JS，CSS，Logo图片等资源独立分布式部署，并采用独立的域名，即<strong>动静分离</strong></li>
<li><strong>分布式数据和存储</strong>：大型网站需要处理以P为单位的海量数据，单台计算机无法提供如此大的存储空间，这些数据需要分布式存储。除了对传统的关系数据库进行分布式部署外，各种NoSQL产品几乎都是分布式的</li>
<li><strong>分布式计算</strong>：严格来说，应用、服务、实时数据处理都是计算，网站除了要处理这些在线业务，还有很大一部分用户没有直观感受的后台业务要处理，包括搜索引擎等索引构建、数据仓库等数据分析统计等。目前网站普遍使用Hadoop及其MapReduce分布式计算框架进行此类批处理计算，其特点是移动计算而不是移动数据，将计算程序分发到数据所在到位置以加速计算和分布式计算</li>
</ul>
</li>
<li>还有可以支持网站线上服务器配置实时更新到分布式配置， 分布式环境下实现并发和协同的分布式锁，支持云存储的分布式文件系统等</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul>
<li>使用分布式虽然已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块，还需要独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务</li>
<li>当有更多用户访问的时候，只需要向集群中加入新的机器即可。同时因为一个应用由多台服务器提供，当某台服务器发生故障时，<strong>负载均衡设备或者系统的失效转移机制会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用</strong> </li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>缓存是将数据放在距离计算最近的位置以加快处理速度</li>
<li>缓存设计：<ul>
<li><strong>CDN</strong>：即内容分发网络，部署在距离终端用户最近的网络提供商，用户的网络请求总是先到达他的网络服务商那里，在这里缓存网站的静态资源(较少变化的数据)，可以就近以最快速度返回给用户</li>
<li><strong>反向代理</strong>：反向代理属于网站前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，最先访问的就是反向代理服务器，这里缓存网站的静态资源，无需将请求继续转发给应用服务器就能返回给用户</li>
<li><strong>本地缓存</strong>：在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，而无须访问数据库</li>
<li><strong>分布式缓存</strong>：将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据</li>
</ul>
</li>
<li>使用缓存有两个前提条件，一是数据访问热点不均衡，某些数据会被频繁访问，这些数据应该放在缓存中。二是数据在某段时间段内有效，不会很快过期，否则缓存的数据就会因为已经失效而产生脏读，影响结果的正确性</li>
</ul>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul>
<li>业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行进行协作</li>
<li>在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理，在分布式系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作内存队列的分布式部署</li>
<li>异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常便利。除此之外，使用异步消息队列还有如下特性：<ul>
<li><strong>提高系统可用性</strong>：消费者服务器发生故障，数据会在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障。消费者服务器恢复正常后，继续处理消息队列中的数据</li>
<li><strong>加快网站响应速度</strong>：处在业务处理前端的生产者服务器在处理完业务请求后，将数据写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟减少</li>
<li><strong>消除并发访问高峰</strong>：用户访问网站是随机的，存在访问高峰和低谷，即使网站按照一般访问高峰进行规划和部署，也依然会出现突发事件。使用消息队列将突然增加的访问请求数据放入消息队列中，等待消费者服务器依次处理，就不会对整个网站负载造成太大压力</li>
</ul>
</li>
</ul>
<h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><ul>
<li>要想保证服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样当某台服务器宕机时，可以将其上的服务和数据访问转移到其它机器上</li>
<li>数据库出了定期备份，实现冷备份外，为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份</li>
</ul>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><ul>
<li>通过减少人为干预，使发布<strong>过程自动化</strong>可有效减少故障。发布过车过包括诸多环节。<strong>自动化代码管理</strong>，代码版本控制、代码分支创建合并等过程自动化，开发工程师制药提交自己参与开发的产品编号，系统就会自动为其创建开发分支，后期会自动进行代码合并；<strong>自动化测试</strong>，代码开发完成，提交测试后，系统自动将代码部署到测试环境，启动自动化测试用例进行测试，向相关人员发送测试报告，向系统反馈测试结果；<strong>自动化安全检测</strong>，安全检测工具通过对代码进行静态安全扫描及部署到安全测试环境进行安全攻击测试，评估其安全性；最后进行<strong>自动化部署</strong>，将工程代码自动部署到线上生产环境 </li>
<li>此外，网站可以会遇到各种问题：服务器宕机、程序bug、存储空间不足、突然爆发的访问高峰。网站需要对线上生产环节进行<strong>自动化监控</strong>，对服务器进行心跳检测，并监控其各项性能指标和应用程序的关键数据指标。如果发现异常、超出预设的阀值，就进行<strong>自动化报警</strong>，向相关人员发送报警信息，警告故障可能会发生。在检测到故障发生后，系统会进行<strong>自动化失效转移</strong>，将失效的服务器从集群中隔离出去，不再处理系统中的应用请求。待故障消除后，系统进行<strong>自动化失效恢复</strong>，重新启动服务，同步数据保证数据的一致性。在网站遇到访问高峰，超出网站最大处理能力时，为了保证整个网站的安全可用，还会进行<strong>自动化降级</strong>，通过拒绝部分请求及关闭部分不重要的服务将系统负载降至一个安全的水平，必要时，还需要<strong>自动化分配资源</strong>，将空闲资源分配给总要的服务，扩大其部署规模</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>安全架构：通过<strong>密码</strong>和<strong>手机校验码</strong>进行身份认证；登录、交易等操作需要对网络通信进行<strong>加密</strong>，网站服务器上存储的敏感数据如用户信息等也进行加密处理；为了防止机器人程序滥用网络资源攻击网站，网站使用<strong>验证码</strong>进行识别；对于常见的用于<strong>攻击</strong>网站的XSS攻击、SQL注入，进行编码转换等相应处理；对于垃圾信息、敏感信息进行过滤；对交易转账等重要操作根据交易模式和交易信息进行风险控制</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;大型网站架构模式&quot;&gt;&lt;a href=&quot;#大型网站架构模式&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构模式&quot;&gt;&lt;/a&gt;大型网站架构模式&lt;/h1&gt;&lt;h2 id=&quot;分层&quot;&gt;&lt;a href=&quot;#分层&quot; class=&quot;headerlink&quot; title=&quot;分层&quot;&gt;&lt;/a&gt;分层&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分层是：将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统&lt;/li&gt;
&lt;li&gt;在大型网站分层架构中，将网站软件系统分为应用层、服务层和数据层&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;负责具体业务和试图展示，如网站首页及搜索输入和结果展示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务层&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;为应用层提供服务支持，如用户管理服务，购物车服务等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据层&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;提供数据存储访问服务，如数据库、缓存、文件、搜索引擎等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="架构" scheme="http://blog.golearns.org/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="集群" scheme="http://blog.golearns.org/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="分布式" scheme="http://blog.golearns.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="读写分离" scheme="http://blog.golearns.org/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
      <category term="CND" scheme="http://blog.golearns.org/tags/CND/"/>
    
      <category term="反向代理" scheme="http://blog.golearns.org/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构演化</title>
    <link href="http://blog.golearns.org/2017/05/11/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96/"/>
    <id>http://blog.golearns.org/2017/05/11/大型网站架构演化/</id>
    <published>2017-05-11T13:11:23.000Z</published>
    <updated>2017-05-11T15:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大型网站架构演化"><a href="#大型网站架构演化" class="headerlink" title="大型网站架构演化"></a>大型网站架构演化</h1><h2 id="初始阶段的网站架构"><a href="#初始阶段的网站架构" class="headerlink" title="初始阶段的网站架构"></a>初始阶段的网站架构</h2><ul>
<li>小型网站最开始没有多少人访问，只需要一台服务器就绰绰有余</li>
<li>应用程序、数据库、文件等所有的资源都放在一台服务器上</li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server1.png" alt=""></p>
<a id="more"></a>
<h2 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h2><ul>
<li>随着网站业务发展，越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。这时就需要应用和数据分离。</li>
<li>应用服务器、文件服务器和数据库服务器<ul>
<li>应用服务器：<strong>处理大量的业务逻辑，需要更快更强大的CPU</strong></li>
<li>文件服务器：<strong>存储大量用户上传的文件，需要更大的硬盘</strong></li>
<li>数据库服务器：<strong>快速磁盘检索和数据缓存，需要更快的硬盘和更大的内存</strong></li>
</ul>
</li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server2.png" alt=""></p>
<h2 id="使用缓存改变网站性能"><a href="#使用缓存改变网站性能" class="headerlink" title="使用缓存改变网站性能"></a>使用缓存改变网站性能</h2><ul>
<li>网站访问特点：<strong>80%的业务访问集中在20%的数据上</strong></li>
<li>把集中访问的一小部分数据缓存在内存中就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库写入性能</li>
<li>网站缓存分为两种：缓存在应用服务器的<strong>本地缓存</strong>和缓存在专门<strong>分布式缓存服务器上的远程缓存</strong><ul>
<li>本地缓存：<strong>访问速度更快，但是受应用服务器内存限制，缓存数据量有限，而且会出现和应用服务器争用内存的情况</strong></li>
<li>远程缓存：<strong>可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器，理论上做到不受内存容量限制的缓存服务</strong></li>
</ul>
</li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server3.png" alt=""> </p>
<h2 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h2><ul>
<li>通过增加服务器分担原有服务器的访问及存储压力，从而实现系统的可伸缩性</li>
<li>通过负载均衡调度服务器，可将来自用户浏览器的访问请求转发到应用服务器集群中的任何一台服务器上，如果有个更多的用户，就在集群中加入更多的应用服务器，使应用服务器的负载压力不在成为整个网站的瓶颈</li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server4.png" alt=""></p>
<h2 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h2><ul>
<li>网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作<strong>(缓存访问不命中、缓存过期)</strong>和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈</li>
<li>目前大部分主流数据库提供<strong>主从热备</strong>，通过配置两台数据库主从关系，可以将一台服务器数据库的数据更新同步到另外一台服务器上。网站利用数据库读写分离改善数据库的负载压力</li>
<li>应用服务器在写数据的时候，<strong>访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获取数据</strong></li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server5.png" alt=""></p>
<h2 id="使用反向代理和CND加速网站响应"><a href="#使用反向代理和CND加速网站响应" class="headerlink" title="使用反向代理和CND加速网站响应"></a>使用反向代理和CND加速网站响应</h2><ul>
<li>随着网站业务不断发展，用户规模越来愈大，由于中国复杂的网络环境，不同地区的用户访问网站时，速度差别较大。</li>
<li>网站加速手段有<strong>CDN</strong>和<strong>反向代理</strong></li>
<li>CDN和反向代理的基本原理都是缓存。<ul>
<li>CDN部署在网络提供山的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据</li>
<li>反向代理部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户</li>
</ul>
</li>
<li>使用CDN和反向代理一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力 </li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server6.png" alt=""></p>
<h2 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h2><ul>
<li>分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务拆分，<strong>将不同的业务的数据库部署在不同的物理服务器上</strong></li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server7.png" alt=""></p>
<h2 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h2><ul>
<li>随着网站业务越来越复杂，对数据存储的检索需求也越来越复杂，网站需要采用一些非关系型数据库如NoSQL和非数据库查询技术如搜索引擎</li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server8.png" alt=""></p>
<h2 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h2><ul>
<li>大型网站为了应对复杂的业务场景，通过将整个网站业务分成不同的产品线，如大型购物交易网站就会将首页、商铺、订单、买家、卖家等拆分成不同的产品线</li>
<li>具体到技术：将一个网站拆分成许多不同的应用，每个应用独立部署维护</li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server9.png" alt=""></p>
<h2 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h2><ul>
<li>既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作</li>
</ul>
<p><img src="http://opsi4gg7g.bkt.clouddn.com/server10.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;大型网站架构演化&quot;&gt;&lt;a href=&quot;#大型网站架构演化&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构演化&quot;&gt;&lt;/a&gt;大型网站架构演化&lt;/h1&gt;&lt;h2 id=&quot;初始阶段的网站架构&quot;&gt;&lt;a href=&quot;#初始阶段的网站架构&quot; class=&quot;headerlink&quot; title=&quot;初始阶段的网站架构&quot;&gt;&lt;/a&gt;初始阶段的网站架构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;小型网站最开始没有多少人访问，只需要一台服务器就绰绰有余&lt;/li&gt;
&lt;li&gt;应用程序、数据库、文件等所有的资源都放在一台服务器上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://opsi4gg7g.bkt.clouddn.com/server1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://blog.golearns.org/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="集群" scheme="http://blog.golearns.org/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="分布式" scheme="http://blog.golearns.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="读写分离" scheme="http://blog.golearns.org/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
      <category term="CND" scheme="http://blog.golearns.org/tags/CND/"/>
    
      <category term="反向代理" scheme="http://blog.golearns.org/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
</feed>
